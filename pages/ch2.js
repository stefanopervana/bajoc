import Layout from '../components/layout'

export default () => (
  <Layout title='Chapter 2'>
    <div>
    <style jsx>{`

                    .col-md-6 {
                        border-radius: 4px;
                        overflow: hidden;
                        box-shadow: 0 9px 9px rgba(0, 0, 0, 0.9);
                        display: block;
                        min-height: 70%;
                        font-family: Verdana;
                        max-width: 1100px;
                        background-color: #E8EDEE;
                        margin: auto;
                        margin-top: auto;
                        margin-right: auto;
                        margin-bottom: auto;
                        margin-left: auto;
                        white-space: pre-wrap;
                        border: none;
                        box-sizing: border-box;
                        color: #2D0D0D;
                        line-height: 1.1;
                        padding: 4.7em;

                    }

                    .home {
                        margin: 1.5em 0;
                        
                    }

                    h1 {
                        color: #867452;
                        font-size: 60px;
                    }

                    h2 {
                        color: #867452;
                        font-size: 40px;
                    }
                    
                    h3 {
                        color: #867452;
                        font-size: 30px;
                    }


                    .it, .listit {
                        color: brown;
                        font-size: 24px;
                        font-style: italic;
                        letter-spacing: 0.04em;
                    }
                    .p, .listitem {
                        color: #75AFAD;
                        font-size: 24px;
                        font-style: italic;
                        letter-spacing: 0.04em;
                    }

                    pre {display: block;
                    font-family: monospace;
                    white-space: pre;
                    margin: 1em 0;
                    font-size: 16px


                    }

                    code
                    {margin: auto,
                        font-family:"Lucida Console";
                        "Andale Mono";
                        "Courier New";
                        Courier;
                        monospace;
                        font-style:normal;
                        color:#395C73;}
                    
                    code strong
                    {color:#000;
                        background:#F5FD11;
                        padding:1px;
                        font-weight:normal;
                    }

                    .interno {
                    font-family: verdana;
                    font-style: italic;
                    color: #395C73;
                    font-size: 24px;    
                    }

                    .sub{
                        text-decoration: underline;
                    }
                `}</style>

    <div className="col-md-6">     

    
<h1>Chapter 2: React at a High Level</h1>
<h2>What Is React?</h2>
<p className="it">React es una biblioteca JavaScript de código abierto para crear interfaces de usuario. Su objetivo es abordar los problemas de la construcción de grandes aplicaciones con datos que cambian con el tiempo. desarrollado originalmente en Facebook, ahora se utiliza en un número de compañías, incluyendo Netflix, Instagram, Airbnb y HelloSign.</p>
<p className="p">React is an open-source JavaScript library for creating user interfaces. It aims to address the problems of building large applications with data that changes over time. Originally developed at Facebook, it is now used in a number of companies including Netflix, Instagram, Airbnb, and HelloSign.</p>
<p className="it">React sólo se refiere al renderizado de la interfaz de usuario de un modelo de datos y en su mayoría no es pertinaz sobre la forma de estructurar sus aplicaciones, dejando que dependa del desarrollador. Sobre todo no se preocupar por la forma en que trae y manipula los datos. Eso hace a React extremadamente flexible. Se puede utilizar con otras bibliotecas / frameworks no relacionadas, como Backbone y Angular, con Flux⁷, o con su propia solución personalizada. Es muy simple, pero increíblemente potente. Su simplicidad hace que sea fácil de aprender en un corto período de tiempo.</p>
<p className="p">React is only concerned with rendering the UI from a data model and is mostly not opinionated about how you structure your applications, leaving that up to the developer. It is mostly unconcerned with how data is fetched and handled. That makes React extremely flexible. You can use it with other unrelated libraries/frameworks like Backbone and Angular, with Flux⁷, or with your own custom solution. It is very simple yet incredibly powerful. Its simplicity makes it easy to pick up in a short amount of time.</p>
<p className="index">⁷https://facebook.github.io/flux/docs/overview.html</p>
<h2>How React Views the World</h2>
<p className="it">La belleza de React está en su filosofía hacia el desarrollo de aplicaciones. React introduce un nuevo conjunto de ideas para el desarrollo web, que van en contra de muchas buenas prácticas establecidas, que nosotros como industria hemos llegado a aceptar en el desarrollo web front-end. Su enfoque es muy diferente a lo que hemos visto en la web hasta el momento. React anima a los desarrolladores a alejarse del MVC (Modelo + Vista-Controlador) y en su lugar adoptar un enfoque basado en el componente de interfaz de usuario. Para React, el cliente no debe pensarse en términos de MVC, sino más bien un conjunto de componentes de interfaz de usuario anidados.</p>
<p className="p">React’s beauty is in it’s philosophy toward application development. React introduces a whole new set of ideas to web development which go against many established best practices, which we as an industry have come to accept in front-end web development. Its approach is very different to what we have seen on the web so far. React encourages developers to move away from MVC (Model- View-Controller) and instead adopt a UI component based approach. To React, the client should not be thought of in terms of MVC, but rather a collection of nested UI components.</p>
<p className="it">Mientras que las aplicaciones MVC JavaScript pueden ser descritas en términos de programación orientada a objetos, React se mueve más hacia un enfoque basado en interfaces de usuario funcional. Al igual que las funciones reutilizables simples, React ayuda a organizar nuestras aplicaciones en componentes de interfaz de usuario reutilizables. Por eso React se ocupa principalmente de la capa de presentación de la solicitud, ya que es lo que debe impulsar el diseño de una aplicación. Al adoptar este enfoque, la decisión del diseño de React ayuda a simplificar el problema de la gestión de estados en aplicaciones web de gran escala.</p>
<p className="p">While MVC JavaScript applications can be described in terms of Object Oriented Programming, React moves more toward a functional approach based user interfaces. Just like simple reusable functions, React helps organize our applications into reusable UI components. That is why React is primarily concerned with an application’s presentation layer since that is what should drive an application’s design. By taking this approach, React design decision helps simplify the problem of managing state in large scale web applications.</p>
<h2>React Is Not MVC</h2>
<p className="it">El hecho de que sólo React se preocupa por presentar la interfaz de usuario ha llevado a algunos a concluir que React se debe considerar la “V” en “MVC”, que es algo engañoso. Mientras que podrías utilizar React como la capa de la vista de una arquitectura MVC, te negarías muchos de los beneficios del uso de React. Es mucho más que una biblioteca de plantillas. Se trata de una forma completamente diferente de crear aplicaciones web.</p>
<p className="p">The fact that React only cares about presenting the UI has led some to conclude that React should be considered the “V” in “MVC”, which is somewhat misleading. While you could use React as the view layer of an MVC architecture, that would negate many of the benefits of using React. It is much more than just a templating library. It is a completely different way of building web applications.</p>
<p className="it">Su filosofía mayormente rechaza el MVC/MV* en el navegador. Esto es debido a que el entorno del navegador es muy diferente del servidor, donde tradicionalmente se utiliza MVC. MVC es una excelente idea en el servidor. <span className="sub">El trabajo del servidor es crear el estado del medio ambiente sin estado de HTTP</span>. En tal ambiente, MVC tiene mucho sentido. Dado el éxito de MVC en el servidor, no es de extrañar que hallamos estado tratando de usarlo en el navegador.</p>
<p className="p">Its philosophy mostly rejects MVC/MV* in the browser. That is because the browser environment is very different from the server, where we traditionally use MVC. On the server, MVC is an excellent idea. The server’s job is to create state out of the stateless environment of HTTP. In such an environment, MVC makes a lot of sense. Given the success of MVC on the server, it is no wonder why we have been trying to use it on the browser.</p>
<p className="it">En estos días, las aplicaciones web son algo más que un servidor que sirve HTML estático y CSS. Con la gran mejora de los motores de navegador de JavaScript junto con el aumento de las excelentes experiencias de los usuarios que se encuentran en las aplicaciones nativas, como industria hemos empezado a empujar los datos y el comportamiento hacia el cliente. Este fue un gran paso adelante para la web, pero como desarrolladores web esto nos dejó luchando por encontrar formas de trabajar en el entorno hostil del navegador.</p>
<p className="p">These days, web applications are more than just a server serving static HTML and CSS. With the vast improvement of browser JavaScript engines along with the rise of excellent user experiences found in native applications, we as an industry have increasingly started pushing data as well as behavior to the client. This was a great step forward for the web, but as web developers this left us scrambling to find ways to work in the hostile browser environment.</p>
<p className="it">Comprendemos que las ideas que nos sirvieron bien en el servidor, tales como MVC, las hemos tratado de aplicar al navegador. Si MVC ayudó a separar preocupaciones en el servidor, parece lógico utilizarlo para separar preocupaciones en el navegador. En ese momento, esto parecía tener mucho sentido y de hecho fue una gran mejora para el lado del cliente JavaScript. Si bien han servido a un propósito muy útil, los frameworks MVC no son el final de la historia para crear aplicaciones web. Asi como jQuery ayudó a mover hacia adelante la web, los frameworks MVC ayudaron a dar empuje para construir experiencias de usuario ricas para la web, pero no es la última palabra en ese espacio.</p>
<p className="p">We understandably took the ideas that served us well on the server, such as MVC, and have attempted to apply them to the browser. If MVC helped separate concerns on the server, it seems logical to use it to separate concerns in the browser. At the time, this seemed to make a lot of sense and indeed was a great improvement for client-side JavaScript. While they have served a very useful purpose, MVC frameworks are not the end of history for building web applications. Much like how jQuery helped move the web forward, MVC frameworks helped the push to build rich user experiences for the web but is not the final word in that space.</p>
<p className="it">No todos los desarrolladores web han adoptado la idea de que las aplicaciones web del lado del cliente son el futuro o incluso útiles. Esto se debe a que el desarrollo de los frameworks MVC JavaScript son muy lentos y complicados, debido a la aplicación de un paradigma apropiado para un entorno diferente. Los desafíos únicos presentados por el lado del navegador JavaScript requieren un conjunto diferente de ideas para hacerle frente de manera efectiva. El problema de forzar a MVC en el navegador es que intenta separar la preocupación de que están íntimamente relacionados.</p>
<p className="p">Not all web developers have adopted the idea that client-side web applications are the future or even useful. This is because development in MVC JavaScript frameworks is painfully slow and complicated, due to the application of an inappropriate paradigm to a different environment. The unique challenges presented by browser side JavaScript require a different set of ideas to tackle them effectively. The problem with forcing MVC on the browser is; it attempts to separate concerns that are inextricably linked.</p>
<p className="it">Como Actually Separate Concerns: Escribir Componentes, No Plantillas MVC. Tiene sentido en el entorno sin estado de HTTP y servidores web, pero tiene menos sentido en aplicaciones de una sola página. Esto es así porque a diferencia del entorno de servidor, el navegador está llena de estado. El servidor se ocupa de las peticiones y respuestas, pero el navegador es una interfaz de usuario con una gran cantidad de eventos y con la interacción del usuario. MVC en el navegador intenta separar las cosas que realmente van de la mano, que a su vez oscurece el estado de una aplicación.</p>
<p className="p">How to Actually Separate Concerns: Write Components, Not Templates MVC makes sense in the stateless environment of HTTP and webservers but it makes less sense in single page applications. That is because unlike the server environment, the browser is full of state. The server is concerned with requests and responses, but the browser is a user interface with a lot of events and user interaction. MVC on the browser tries to separate things that actually belong together, which in turn obscures the state of an application.</p>
<p className="it">Los frameworks de JavaScript MVC tratan de separar lo que en realidad va de la mano que es la lógica de visualización y markup. Esto es un error. React piensa que debe dejar las plantillas de escritura: se deben escribir componentes. Esto significa que tenemos que dejar de separar nuestro HTML a partir de nuestro JavaScript.</p>
<p className="p">One thing JavaScript MVC frameworks try to separate which actually belong together is display logic and markup. This is a mistake. React thinks that you should stop writing templates: you should be writing components. This means that we need to stop separating out HTML from our JavaScript.</p>
<p className="it">Esto va en contra de todo lo que hemos llegado a creer en la comunidad JavaScript. De hecho, la afirmación anterior es suficiente para que muchos despidan a React. Por un momento, dejemos a un lado el dogma y analizemos el tema como si nos acercaramos a el por primera vez.</p>
<p className="p">This goes against everything we have come to believe in the JavaScript community. In fact, the above statement is enough for many to dismiss React. For just a moment, let us set dogma aside and analyze the issue as if approaching it for the first time.</p>
<p className="it">React afirma que el markup y la lógica de visualización están íntimamente relacionados. Cada vez que cambie el markup, está obligado a afectar el comportamiento que escribió en JavaScript. Y cuando se cambia el comportamiento, sin duda va a actualizar el markup. Ese no es siempre el caso, pero eso es una preocupación. Esto se parece mucho al estrecho acoplamiento en un sistema. Al tratar de separar una interfaz de usuario entre las plantillas y los controllers/view-models, nosotros no estamos separando preocupaciones â€“ estamos separando tecnologías.</p>
<p className="p">React asserts markup and display logic are inextricably linked. Whenever you change markup, you are bound to affect the behavior you wrote in JavaScript. And when you change the behavior, you are undoubtedly going to update the markup. That is not always the case, but that is a concern. This looks a lot like tight coupling in a system. By trying to separate a UI between templates and controllers/view-models, we are not separating concerns â€“ we are separating technologies.</p>
<p className="it">Antes de continuar, debemos definir lo que significa “separación de intereses”. La separación de las preocupaciones realmente trata acerca de que la reducción de acoplamiento al mismo tiempo aumenta la cohesión. El acoplamiento en un sistema es la cantidad de piezas que dependen unas de otras. Cohesión se refiere al grado en el que elementos de un sistema permanecen juntos. Las plantillas y la lógica de visualización tienen acuerdos implícitos entre sí, lo que significa; si cambia uno, puede que tenga que cambiar el otro, lo que conduce a cambios en cascada. Se trata de acoplamiento. Así que mediante la separación del markup y la lógica de visualización, en realidad está aumentando en todo el sistema de acoplamiento. Mientras tanto, también está disminuyendo la cantidad de cohesión en la aplicación. La lógica de visualización y de markup es muy cohesiva; ambas están preocupadas por mostrar la interfaz de usuario para el usuario. Separándolas, estamos reduciendo la cohesión y la capacidad del desarrollador de razonar acerca de la estructura de la aplicación.</p>
<p className="p">Before we continue, we should define what “separation of concerns” means. Separation of concerns is really about reducing coupling while simultaneously increasing cohesion. Coupling is how much pieces of a system depend on each other. Cohesion refers to the degree to which elements of a system belong together. Templates and display logic have implicit agreements among themselves, meaning; if you change one, you might have to change the other, which leads to cascading changes. This is coupling. So by separating markup and display logic, you are actually increasing coupling throughout your system. Meanwhile, you are also decreasing the amount of cohesion in your application. Display logic and markup are very cohesive; they are both concerned with showing the UI to the user. By separating them, you are reducing cohesion and the developer’s ability to reason about the structure of the application.</p>
<p className="it">Para ser justos, las plantillas y la lógica de visualización generalmente resultan finas de separar. Pero hay un mejor enfoque. A las preocupaciones verdaderamente independientes, se debe escribir componentes. Los frameworks no pueden separar las preocupaciones por vos. Vos mismo podes hacer un mejor trabajo de separar las preocupaciones. Separar preocupaciones mediante la creación de pequeños componentes responsables del renderizado sólamente de una pequeña porción de la interfaz de usuario. La visualización de una pieza de la interfaz de usuario está encapsulada en un solo lugar. Dicho componente es a la vez desacoplado del resto de su sistema y cohesionado.</p>
<p className="p">To be fair, seperating templates and display logic usually turns out fine. But there is a better approach. To truly separate concerns, you should be writing components. Frameworks cannot separate concerns for you. You can do a much better job of separating concerns yourself. You separate concerns by creating small components responsible for rendering just a small piece of the UI. Displaying a piece of the UI is now encapsulated in one place. Such a component is both decoupled from the rest of your system and cohesive.</p>
<p className="it">Además, los componentes pequeños son reutilizables, componibles, y sobre todo, la unidad es comprobable. En esencia, los componentes son funciones idempotent a los que cuando se les da un conjunto de datos siempre devolverán el mismo resultado de interfaz de usuario, haciéndolos mucho más fáciles de probar. La programación funcional de React esencialmente es la presentación de la UI.</p>
<p className="p">In addition, small components are reusable, composable, and above all, unit testable. Essentially, components are idempotent functions that when given a set of data will always return the same UI result, making them much easier to test. React essentially introduced functional programing to the UI.</p>
<p className="it">Vamos a echar un vistazo a como se ve un componente en React. He aquí un pequeño ejemplo.</p>
<p className="p">Let’s take a look at what a component looks like in React. Here’s a small example.</p>
<div className="image"><a></a><img src="/static/cod001.jpg" width="100%" alt="Image"/></div>
<p className="it">Lo primero y más probable es que te enteres de lo parecido que es a HTML insertado en nuestro JavaScript. En realidad no es HTML. Es JSX. Es el azúcar sintáctico en la parte superior de JavaScript claro que hace que el markup sea fácil de declarar. Cuando se compila a JavaScript regular, se verá así:</p>
<p className="p">The first thing you will most likely notice is what looks like HTML in our JavaScript. It is not actually HTML. This is JSX. It is syntactic sugar on top of plain JavaScript that makes it easy to declare markup. When compiled to regular JavaScript, it will look like this:</p>
<div class="image"><a></a><img src="/static/cod002.jpg" width="100%" alt="Image"/></div>
<p className="it">El JSX no es necesario para trabajar con React, pero su uso hace que sea mucho más fácil crear componentes que son semántica y fáciles de entender de un vistazo. En estos días, la mayoría de los proyectos de JavaScript están utilizando algún tipo de sistema de construcción y tal vez usar ese sistema de construcción a utilizar ES2015, por lo que, en comparación, añadir un pequeño paso de compilación para JSX es trivial. De hecho, Babel⁸, que es posiblemente el compilador de JavaScript más popular hoy dia, apoya a JSX.</p>
<p className="p">JSX is not needed to work with React, but using it makes it much easier to create components that are semantic and easy to understand at a glance. These days, most JavaScript projects are using some kind of build system and perhaps using that build system to use ES2015, so adding a small compilation step for JSX is trivial in comparison. In fact, Babel⁸ supports JSX, which is arguably the most popular JavaScript compiler today.</p>
<p className="index">⁸https://babeljs.io/</p>
<p className="it">Estamos pasando un método <code>{`render()`}</code> en un objeto <code>{`React.createClass`}</code> para crear el componente HelloWorld. <code>{`render()`}</code> es el método más importante en React. Es el corazón de un componente React. <code>{`render()`}</code> es llamado cada vez que los componentes de React consiguen ser renderizados a HTML.</p>
<p className="p">We are passing a <code>{`render()`}</code> method in an object to <code>{`React.createClass`}</code> to create the HelloWorld component. <code>{`render()`}</code>) is the most important method in React. It is the heart of a React component. <code>{`render()`}</code> gets called every time the React components gets rendered to HTML.</p>
<p className="it">Es importante señalar que <code>{`render()`}</code> no devuelve un h1 - devolverá una representación en la memoria de un nodo DOM que con el tiempo se utiliza para crear un h1 en la representación de la memoria de la situación actual del DOM, el DOM virtual. Más sobre esto en un capítulo futuro.</p>
<p className="p">It is important to point out that <code>{`render()`}</code> does not return an h1 – it will return an in memory representation of a DOM node that will eventually be used to create an in memory representation of the current state of the DOM, the Virtual DOM. More about that in a future chapter.</p>
<p className="it">Ahora que tenemos este componente, podemos reutilizarlo en otra parte:</p>
<p className="p">Now that we have this component, we can reuse it elsewhere:</p>
<div class="image"><a></a><img src="/static/cod003.jpg" width="100%" alt="Image"/></div>
<p className="it">Anteriormente, creamos el componente <code>{`HelloWorld`}</code> un nuevo componente de encabezado que se reutiliza. En lugar de utilizar una plantilla parcial, podemos simplemente reutilizar componentes en cualquier lugar que nos gusta. Tenemos la accesibilidad de las plantillas con el poder de JavaScript. Podes escribir toda tu aplicación en JavaScript y hacer llamadas a funciones que se parecen a markup, lo que te permite refactorizar claramente sin tener que preocuparse por romper tus plantillas o viceversa.</p>
<p className="p">Above, we created a new Header component that is reusing the <code>{`HelloWorld`}</code> component. Instead of using a template partial, we can simply reuse components anywhere we like. We have the accessibility of templates with the power of JavaScript. You can write your whole app in JavaScript and function calls that look like markup, allowing you to clearly refactor without worrying about breaking your templates or vice versa.</p>
<p className="it">Pero esto sigue siendo una muy pequeña muestra sin ningún tipo de datos, estado o comportamiento. Mirá la forma en que piensa React sobre todas esas cosas.</p>
<p className="p">But this is still a pretty small example without any data, state, or behavior. Let’s dive into how React thinks about all those things.</p>
<h2>Data Binding</h2>
<p className="it">Las interfaces de usuario son muy difíciles de construir debido a la cantidad de estado que se encuentra en ellas. El estado es la raíz de todos los males, como muchos han observado⁹. Todo el estado de las interfaces de usuario se entrelaza para crear un sistema complejo que es muy difícil de entender para los humanos.</p>
<p className="p">User interfaces are very difficult to build due to the amount of state found in it. State is the root of all evil, as many have observered⁹. All the state in user interfaces intertwines to create a complex system that is very difficult for humans to understand.</p>
<p className="index">⁹https://twitter.com/steveklabnik/status/343179719136649216</p>
<p className="it">¿Por qué el state es tan difícil de entender? En esencia, es el estado de tus datos en cualquier punto dado en el tiempo. En otras palabras, <span classname="sub">el estado es datos que cambian con el tiempo - es mutable</span>. Los cerebros humanos no están muy bien orientados a razonar acerca de los sistemas que cambian con el tiempo. Somos dueños de  comprender relaciones estáticas y en nuestro cerebro no existe ningún problema de mantenimiento de esas relaciones. Sin embargo, tenemos un momento muy duro para hacer el seguimiento de las relaciones dinámicas que cambian con el tiempo (ver condition¹⁰ raza). Cuando los datos están en constante flujo, los seres humanos tienen un momento difícil tratando de razonar sobre exactamente lo que está sucediendo en cualquier punto dado en el tiempo.</p>
<p className="p">Why is state so hard to understand? Essentially, state is your data at any given point in time. In other words, state is data that changes over time – it is mutable. Human brains, as it turn out, are not very well geared toward reasoning about systems that change over time. We are masters of understanding static relationships and have no problem keeping those relationships in our brains. However, we have a really hard time at keeping track of dynamic relationships that change over time (see race condition¹⁰). When data is constantly in flux, we humans have a hard time trying to reason about exactly what is going on at any given point in time.</p>
<p className="index">¹⁰https://en.wikipedia.org/wiki/Race_condition</p>
<p className="it">Entonces, ¿cómo nosotros, como programadores, manejamos el estado en interfaces de usuario? Tradicionalmente, hemos hecho esto a través del enlace de datos. Esto ayuda a transformar un proceso dinámico en uno más estático. El enlace de datos hace que la interfaz de usuario se vea más como un programa estático en relación con nuestros datos. En otras palabras, el enlace de datos sincroniza el estado de la interfaz de usuario con un modelo de datos.</p>
<p className="p">So how do we, as programmers, master state in user interfaces? Traditionally, we have done this via data binding. This helps to transform a dynamic process into a more static one. Data binding makes the UI look more like a static program relative to our data. In other words, data binding syncs UI state with a data model.</p>
<p className="it">El enlace de datos es una de las muchas grandes ideas que vienen desde la década del 70, pero en JavaScript no es perfecto. El problema con el enlace de datos en JavaScript es que se trata de un polyfill para la programación reactiva en el DOM. ¿A qué nos referimos con eso?</p>
<p className="p">Data binding is one of many great ideas to come from the 1970’s but in JavaScript it is not perfect. The problem with data binding in JavaScript is that it is a polyfill for reactive programming in the DOM. What do we mean by that?</p>
<p className="it">La programación reactiva merece su propio libro, por lo que no queremos hablar demasiado de ello en este libro. La programación reactiva es un poco difícil de entender al principio, pero básicamente es la programación con flujos de datos asíncronos. Por desgracia, JavaScript no es en realidad reactivo. Echá un vistazo a este ejemplo muy simple:</p>
<p className="p">Reactive programming deserves its own book, so we will not talk about it too much in this book. Reactive programming is a little difficult to grasp at first, but it is basically programming with asynchronous data streams. Unfortunately, JavaScript is not actually reactive. Take a look at this very simple example:</p>
<div class="image"><a></a><img src="/static/cod004.jpg" width="100%" alt="Image"/></div>
<p className="it">En el ejemplo anterior, <code>{`c`}</code> todavía será igual a <code>{`2`}</code>, incluso después de que cambiamos el valor de <code>{`a`}</code>. Si JavaScript fuera verdaderamente reactivo, el valor de <code>{`c`}</code> estaría automáticamente en sincronía con la suma de <code>{`a`}</code> y <code>{`b`}</code>. Este es un ejemplo muy sencillo. Si deseas obtener más información acerca de la programación reactiva echá un vistazo a este excelente recurso: The Introduction to Reactive Programming You’ve Been Missing¹¹.</p>
<p className="p">In the above example, <code>{`c`}</code> will still equal <code>{`2`}</code> even after we change the value of <code>{`a`}</code>. If JavaScript were truly reactive, the value of <code>{`c`}</code> would be automatically be in sync with the sum of <code>{`a`}</code> and <code>{`b`}</code>. This is a very simple example. If you want to learn more about reactive programming take a look at this excellent resource: The Introduction to Reactive Programming You’ve Been Missing¹¹.</p>
<p className="index">¹¹https://gist.github.com/staltz/868e7e9bc2a7b8c1f754</p>
<p className="it">Ni que decir tiene, esto no es necesariamente un error o fallo en el lenguaje, pero sí un obstáculo si queremos una aplicación reactiva de JavaScript en el DOM. Para lograr esto, la mayoría de los frameworks de JavaScript implementan algún tipo de enlace de datos.</p>
<p className="p">Needless to say, this is not necessarily a mistake or bug in the language, but it does present an obstacle if we want a reactive implementation of JavaScript in the DOM. In order to achieve this, most JavaScript frameworks implement some form of data binding.</p>
<p className="it">Esto no es una abstracción trivial en la parte superior de JavaScript, y como todas las abstracciones, estas implementaciones fugan. La diferencia es; la forma en que gotean, cuando no se producen pérdidas, y lo fácil que es detectar y corregir la fuga?</p>
<p className="p">This is not a trivial abstraction on top of JavaScript, and like all abstractions, these implementations leak. The difference is; how leaky are they, when do they leak, and how easy is it to spot and fix the leak?</p>
<p className="it">Casi todos los frameworks de JavaScript utilizan la Key-Value Observation (KVO) para el enlace de datos (las más prominentes son Ember y Meteor), excepto Angular (que utiliza la comprobación dirty). No vamos a bucear en demasiados detalles sobre estos sistemas en este libro. El principal problema de estos sistemas es que divergen demasiado lejos de algo que se parece mucho más a vainilla JavaScript. También requieren conocimiento profundo del funcionamiento interno de estos sistemas.</p>
<p className="p">Pretty much every JavaScript frameworks uses Key-Value Observation (KVO) for data binding (most prominently Ember and Meteor) except Angular (which uses dirty checking). We will not dive into too much detail into these systems in this book. The main problem with these systems is that they diverge too far away from something that looks a lot more like vanilla JavaScript. They also require deep understanding of the inner workings of these systems.</p>
<p className="it">Esto está lejos de ser ideal. El sistema de enlace de datos ideal intenta pegarse a funciones de JavaScript lisas tanto como sea posible, mientras que le da herramientas simples para la reactividad. No deberías tener que pensar en cómo obra la unión de los datos. Las fugas en la abstracción deben ser predecibles cada vez y fáciles de resolver.</p>
<p className="p">This is far from ideal. The ideal data binding system tries to stick to plain old JavaScript functions as much as possible, while giving you simple tools for reactivity. You should not have to think about how the data binding works. Leaks in the abstraction should be predictable every time and easy to solve.</p>
<p className="it">React se ajusta a esta descripción casi a la perfección. Su sistema de enlace de datos no es perfecto, pero esas fugas son muy bien entendidas y predecibles.</p>
<p className="p">React fits this description almost perfectly. Its data binding system is not perfect, but those leaks are very well understood and predictable.</p>
<h2>Virtual DOM</h2>
<p className="it">El enfoque de React ante el enlace de datos se basa en abstracciones mucho más simples: el DOM virtual. Esencialmente, del sistema DOM virtual React abstrae el DOM, manteniendo una representación virtual del DOM en la memoria y siempre que hay cambios en el modelo de datos, React desencadena una re-procesamiento de los componentes que se basan en los datos.</p>
<p className="p">React’s approach to data binding relies on much simpler abstractions: the Virtual DOM. Essentially, React’s Virtual DOM system abstracts the DOM by keeping a virtual representation of the DOM in memory and whenever the data model changes, React triggers a re-render of the components that rely on that data.</p>
<p className="it">En un nivel alto, React te dará herramientas para describir a lo que tu componente debe ser similar en un momento dado. Así, cada vez que cambia el estado, React comenzará a volver a representar el componente que contiene ese estado, compara la representación virtual anterior del DOM con la nueva representación virtual, y sólo actualizar el DOM con lo que realmente ha cambiado. No tenes que preocuparte como desarrollador acerca de cómo esto realmente funciona, sólo tenes que describir el aspecto de tu componente y se dejar a React que se entere cuando su estado ha cambiado. Dicho esto, vamos a profundizar más en el algoritmo diff del DOM virtual de React en breve.</p>
<p className="p">At a high level, React give you tools to describe what your component should look like at any given time. So, whenever the state changes, React will begin re-rendering the component that contains that state, diff the previous virtual representation of the DOM with the new virtual representation, and only update the DOM with what actually changed. You as a developer do not need to worry about how this really works, you just need to describe what your component looks like and let React know when your state has changed. That being said, we will dive deeper into React’s Virtual DOM diff algorithm shortly.</p>
<p className="it">Vamos a un ejemplo muy simple para ver cómo funciona esto en detalle. Podes reproducir el código aquí: <a src="http://codepen.io/anon/pen/VvrqxO">Demo¹²</a></p>
<p className="p">Let’s look at a very simple example and see how this works in detail. You can play the code here: <a src="http://codepen.io/anon/pen/VvrqxO">Demo¹²</a></p>
<p className="index">¹²http://codepen.io/anon/pen/VvrqxO</p>
<div class="image"><a></a><img src="/static/cod005.jpg" width="100%" alt="Image"/></div>
<p className="it">Podes averiguar lo que hace este sencillo ejemplo sin mucha necesidad de explicación. En primer lugar, estamos estableciendo el estado inicial del componente en <code>{`getInitialState`}</code>. Se puede pensar en este método como una función constructora para el componente, donde estamos estableciendo el valor predeterminado de nombre a null. <code>{`getInitialState`}</code> no se requiere para cada componente React, al igual que una función constructora no siempre es necesaria para crear una clase en la Programación Orientada a Objetos.</p>
<p className="p">You can figure out what this simple example does yourself without much need for explanation. First, we are setting the initial state of the component in <code>{`getInitialState`}</code>. You can think of this method like a constructor function for the component, where we are setting the default value of name to null. <code>{`getInitialState`}</code> is not required for every React component, just like a constructor function is not always needed to create a class in Object Oriented Programming.</p>
<p className="it">Entonces, como se verá, estamos describiendo nuestro componente en el método <code>{`render()`}</code>. Podemos acceder al estado actual del componente a través de <code>{`this.state`}</code>. En el interior de <code>{`render()`}</code>, estamos retornando el estado actual del nombre Cat a través de <code>{`this.state.name`}</code>. También estamos renderizando un campo imput para que el usuario cambie el nombre del gato.</p>
<p className="p">Then we are describing what our component will look like in the <code>{`render()`}</code> method. We can access the current state of the component via <code>{`this.state`}</code>. Inside of <code>{`render()`}</code>, we are returning the current state of the cat name via <code>{`this.state.name`}</code>. We are also rendering an input field to the user to change the name of the cat.</p>
<p className="it">Nótese que estamos añadiendo un controlador de eventos para el campo de imput usando <code>{`onChange = {} this.updateName`}</code>. Cada vez que hay un cambio en el campo de imput, <code>{`updateName()`}</code> será llamado. <code>{`updateName()`}</code> llama a un método especial de React llamado <code>{`setstate()`}</code>. Si <code>{`render()`}</code> puede ser considerado como el corazón de un componente, <code>{`setstate()`}</code> puede ser considerado como el cerebro. <code>{`setstate()`}</code> actualizará el valor de los datos en el estado de los componentes, que a su vez dará lugar a un re-procesamiento de la aplicación.</p>
<p className="p">Notice that we are adding an event handler to the input field using <code>{`onChange = {} this.updateName`}</code>. Whenever there is a change to the input field, <code>{`updateName()`}</code> will be called. <code>{`updateName()`}</code> calls a special React method called <code>{`setstate()`}</code>. If <code>{`render()`}</code> can be considered the heart of a component, <code>{`setstate()`}</code> can be considered the brain. <code>{`setstate()`}</code> will update the value of the data in the components state, which in turn will trigger a re-render of the app.</p>
<p className="it">Si escribis la letra “M” en el campo de imput, será llamado <code>{`updateName()`}</code>, que se agarra del valor del campo de imput y actualiza el state del nombre Cat con <code>{`setstate()`}</code>. React llamará entonces a <code>{`render()`}</code> en el Cat de nuevo con el nuevo estado. Se van a crear dos representaciones virtuales del DOM: el viejo DOM y el nuevo DOM. Hará todos los cambios juntos por lotes y averiguará las mutaciones del DOM más óptimas necesarias para alcanzar el nuevo estado de la interfaz de usuario.</p>
<p className="p">If you type in the letter “M” into the input field, <code>{`updateName()`}</code> will be called, which will grab that value from the input field and update the state of the cat name with <code>{`setstate()`}</code>. React will then call <code>{`render()`}</code> on Cat again with the new state. It will create two virtual representations of the DOM: the old DOM and the new DOM. It will batch all updates together and figure out the most optimal DOM mutations necessary to reach the new state of the UI.</p>
<p className="it">En el momento en que termines de escribir “Mittens”, React habrá desencadenado numerosas re-renderizaciones en <code>{`Cat`}</code>. Esto ,superficialmente, parece que sería lento. De hecho, esta decisión de diseño hace a React muy rápido. Debido a que todo esto se hace en JavaScript, esto se realiza dentro de un repinte del navegador. Incluso en el peor de los casos de decenas de miles de mutaciones DOM, React llevará a cabo una re-renderización dentro del tiempo de repintado del navegador. Esto es debido a la velocidad de los motores de JavaScript modernos y del algoritmo inteligente diffing de React, sobre el que vamos a entrar en más detalles en breve.</p>
<p className="p">By the time you are finished typing “Mittens”, React would have triggered numerous re-renders on <code>{`Cat`}</code>. On the surface, this seems like it would be slow. In fact, this design decision makes React extremely fast. Because this is all done in JavaScript, this is all performed within one repaint of the browser. Even in the worst case scenario involving tens of thousands of DOM mutations, React will perform a re-render within the repaint time of the browser. This is due to the speed of modern JavaScript engines and React’s clever diffing algorithm, which we will go into more detail shortly.</p>
<h2>Data in React</h2>
<p className="it">Además de la DOM virtual, React trata los datos de manera diferente de otros proyectos de JavaScript como Angular o Ember. React separa los datos que cambian con el tiempo (estado) a partir de datos que se mantienen iguales. Lo hace a través de dos conceptos: el state y los props. El state son los datos que van a cambiar con el tiempo, tales como la interacción del usuario.</p>
<p className="p">In addition to the Virtual DOM, React treats data differently from other JavaScript projects like Angular or Ember. React separates data that changes over time (state) from data that stays the same. It does this via two concepts: state and props. state is data that will change over time such as user interaction.</p>
<p className="it">Los componentes deben esforzarse por contener de state tan poco como sea posible. Sin embargo, a veces un componente lo necesita para responder a eventos externos, tales como la interacción del usuario, una solicitud del servidor, o el paso del tiempo. <span className="sub">Para el tipo de datos que cambiaran, los componentes deben mantenerse en el estado. Para los datos que no cambiarán, los componentes deben mantenerse en los props</span>.</p>
<p className="p">Components should strive to contain as little state as possible. However, sometimes a component needs to respond to external events such as user interaction, a server request, or the passage of time. For that kind of data, components should keep that in state. For data that will not change, components should keep that in props.</p>
<div className="atencion">
<blockquote className="atencion">
<p className="it">React recibe props de un componente principal. Al confiar en los props, se convierte a un componente esencialmente en una función idempotente. React ve componentes como funciones, por lo tanto, obliga a los datos solamente a fluir de padres a hijos. Al igual que una función, los datos deben fluir en ella como argumentos. Los datos siempre fluyen sólo en una manera en React: de padres a hijos.</p>
<p className="p">React receive props from a parent component. By relying on props, a component essentially becomes an idempotent function. React sees components as functions, therefore it forces data to only flow from parent to child. Just like a function, data should flow into it as arguments. Data always flow just one way in React from parent to child.</p>
</blockquote></div>
<p className="it">El flujo de datos unidireccional limita los mensajes y los datos que pasan dentro del sistema, por lo que es más fácil de depurar. Puesto que los datos sólo pueden pasar de padres a hijos, es fácil de rastrear el flujo de datos en el sistema. Cuando te encontras con un error, en primer lugar nos fijamos en el componente que pensas que está causando el error. Si no lo encontras allí, a su vez buscas en su padre y así sucesivamente hasta encontrar al culpable. En un patrón MVC, ya que los mensajes viajan por todo el lugar, es mucho más difícil de averiguar el flujo de datos.</p>
<p className="p">Unidirectional data flow limits the messages and data being passed inside the system, making it easier to debug. Since data can only pass from parent to child, it is easy to trace the flow of data in your system. When you come across a bug, first you look at the component you think is causing the bug. If you can’t find it there, you turn to its parent and so on until you find the culprit. In an MVC pattern, since messages travel all over the place, it is much more difficult to figure out the flow of your data.</p>
<p className="it">Vamos a echar un vistazo a un ejemplo de state, props, y el flujo de datos unidireccional. Podes seguirlo aquí: Demo¹³.</p>
<p className="p">Let’s take a look at an example of state, props, and unidirectional data flow. You can follow along here: Demo¹³.</p>
<p className="index">¹³http://codepen.io/anon/pen/OyzowP</p>
<div class="image"><a></a><img src="/static/cod006.jpg" width="100%" alt="Image"/></div>
<p className="it">En este ejemplo, el número de perros y gatos cambia con el tiempo. Por lo tanto, estos datos se deben mantener en el estado. <code>{`Animalrescue`}</code> será el encargado de mantener este estado, así como el renderizado de dos componentes hijos: Los gatos y los perros y un botón para que aumente el número de animales. <code>{`getInitialState`}</code> está fijando los valores iniciales de <code>{`catCount`}</code> y <code>{`dogCount`}</code> a cero. Dentro de la función de <code>{`render()`}</code> de <code>{`AnimalRescue`}</code>, estamos pasando el estado actual de <code>{`catCount`}</code> y <code>{`dogCount`}</code> a sus componentes hijos como accesorios. Hacemos esto al declarar <code>{`<Cats count={this.state.catCount}/>`}</code>. Ahora el componente <code>{`Cat`}</code> tiene acceso a ese valor como accesorios. Desde el punto de vista de los componentes hijos, estos valores son como argumentos de la función. En lo que a ellos respecta, estos datos nunca van a cambiar. Ellos deben ser tratados como dentro de permanencia de los componentes hijos.<code>{`</cats>`}</code></p>
<p className="p">In this example, the number of dogs and cats changes over time. Therefore, this data should be kept in state. <code>{`AnimalRescue`}</code> will be in charge of keeping this state, as well as rendering two child components: Cats and Dogs and a button to increment the number of animals. <code>{`getInitialState`}</code> is setting the initial values of <code>{`catCount`}</code> and <code>{`dogCount`}</code> to zero. Inside of the <code>{`render()`}</code> function of <code>{`AnimalRescue`}</code>, we are passing the current state of <code>{`catCount`}</code> and <code>{`dogCount`}</code> to its child components as props. We do this by declaring <code>{`<Cats count={this.state.catCount}/>`}</code>. Now the <code>{`Cat`}</code> component has access to that value as props. From the point of view of the child components, these values are like function arguments. As far as they are concerned, this data is never going to change. They should be treated as immutable inside of the child components.</p>
<p className="it">Nótese cómo en el componente de los padres llamamos este valor <code>{`catCount`}</code> pero nosotros lo llamamos el recuento en Cats. Esto significa que con el fin de acceder a este valor, Cats tendrá que llamar a <code>{`this.props.count`}</code> y no a <code>{`this.props.catCount`}</code>. Esto se hace deliberadamente para señalar que se puede pasar a cualquier dato como accesorio y llamarlo como quieras.</p>
<p className="p">Notice how in the parent component we are calling this value <code>{`catCount`}</code> but we are calling it count in Cats. That means that in order to access this value, Cats will need to call <code>{`this.props.count`}</code> and not <code>{`this.props.catCount`}</code>. This is done deliberately to point out that you can pass in any data as props and call it whatever you like.</p>
<p className="it">Cuando se hace clic en el botón, es llamado <code>{`moreAnimals()`}</code>, el cual se encarga de calcular el nuevo estado y actualizar el estado a través de <code>{`setstate()`}</code>. Una vez que <code>{`setstate()`}</code> se llama, React ahora sabe que el estado ha cambiado y se da cuenta de qué partes de la interfaz de usuario tiene que cambiar.</p>
<p className="p">When the button is clicked, <code>{`moreAnimals()`}</code> is called, which is in charge of calculating the new state and updating the state via <code>{`setState()`}</code>. Once <code>{`setState()`}</code> is called, React now knows that the state has changed and figures out which parts of the UI that need to change.</p>
<p className="it">Es posible que hayas visto una oportunidad de refactorización aquí. Debido a que React se pega al JavaScript normal tanto como sea posible y los componentes son idempotentes, podes fácilmente refactorizar tu código y crear componentes reutilizables</p>
<p className="p">You may have spotted a refactoring opportunity here. Because React sticks to regular JavaScript as much possible and components are idempotent, you can easily refactor your code and create reusable  components.</p>
<div className="image"><a></a><img src="/static/cod007.jpg" width="100%" alt="Image"/></div>
<p className="it">Ahora <code>{`AnimalRescue`}</code> sólo se preocupa por el state, el comportamiento, y la delegación de la renderización del recuento de los animales al componente <code>{`AnimalCount`}</code>. <code>{`AnimalCount`}</code> sólo se preocupa por el renderizado de una lista desordenada de los datos de animals. La representación de los elementos de la lista se delega en el componente <code>{`AnimalListItem`}</code>. Ahora podemos volver a utilizar <code>{`AnimalListItem`}</code> para hacer más datos en animals que debe comenzar el rescate de más tipos de animals.</p>
<p className="p">Now <code>{`AnimalRescue`}</code> only cares about state, behavior, and delegating rendering of animal count to the <code>{`AnimalCount`}</code> component. <code>{`AnimalCount`}</code> only worries about rendering an unordered list of animal data. Rendering of the list items is delegated to the <code>{`AnimalListItem`}</code> component. Now we can reuse <code>{`AnimalListItem`}</code> to render more animal data should we start rescuing more types of animals.</p>
<div className="atencion">
<blockquote className="atencion">
<p className="it">Con el DOM Virtual y el flujo de datos unidireccional, React convierte la interfaz de usuario en una máquina de state. Cada vez que cambia sus datos, el resto de la aplicación encaja en el lugar adecuado.</p>
<p className="p">With the Virtual DOM and unidirectional data flow, React turns the user interface into a state machine. Whenever your data changes, the rest of your application snaps into the proper place.</p>
</blockquote>
</div>
<p className="it">Aunque esto parece un enfoque novedoso, en realidad no es único - es sólo nuevo en el desarrollo web. React tomó un vistazo a otra área de desarrollo de software, la industria del juego, el cual trajo esas ideas a la web.</p>
<p className="p">While this seems like a novel approach, it is actually not unique – it is just new to web development. React took a look at another area of software development, the gaming industry, and brought those ideas to the web.</p>
<p className="it">En muchos sentidos, las interfaces de usuario basadas en la web tienen más en común con los juegos que con el servidor. Los juegos también están llenos de state (número de armas, los vehículos, los sonidos, los eventos basados ​​en la interacción del usuario, etc...) y toneladas de comportamiento que necesita ser recalculado constantemente y volver a ser representado al jugador a 60 cuadros por segundo. Además de eso, hay limitaciones de hardware difíciles que aún requieren un rendimiento excelente a pesar de esas limitaciones.</p>
<p className="p">In many ways, web based UIs have more in common with games than with the server. Games are also packed full of state (number of weapons, vehicles, sounds, events based on user interaction, etc…) and tons of behavior that needs to be constantly recalculated and re-render the player at 60 frames per second. On top of that, there are tough hardware constraints that still require excellent performance despite those limitations.</p>
<p className="it">De hecho, el ciclo de vida en React es muy similar al motor de Doom 3. En Doom, todo el estado del juego se mantiene en un contenedor de alto nivel, y luego se lo pasa a sus componentes front-end, que contienen la lógica del juego, seguido por la creación de una representación intermedia de la escena, que luego se traducen en operaciones OpenGL y finalmente expulsadas a la tarjeta gráfica. Frow de React es muy similar: el estado de la aplicación vive en componentes más altos que luego transmiten los datos como inmutables a los componentes hijos que en realidad albergan el comportamiento, a continuación, un se crea DOM virtual como una representación intermedia del DOM, finalmente, se dosifican las mutaciones DOM y se actualiza el mismo DOM real.</p>
<p className="p">Indeed, the React lifecycle is very similar to the Doom 3 engine. In Doom, all the state of the game is kept at a high level container, then passes it to its front-end components which contain the game logic, followed by the creation of an intermediate representation of the scene, which then gets translated into OpenGL operations and finally flushed out to the graphics card. React’s frow is very similar: the state of the application lives in higher components which then gets passed down as immutable data to child components which actually house the behavior, then a Virtual DOM is created as an intermediate representation of the DOM, finally batching of the DOM mutations and updating the real DOM itself.</p>
</div>
</div>
  </Layout>
)
