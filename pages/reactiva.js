import Layout from '../components/layout'

export default () => (
  <Layout title='Chapter 5'>
    <div><style jsx>{`                    .col-md-6 {
                        border-radius: 4px;
                        overflow: hidden;
                        box-shadow: 0 9px 9px rgba(0, 0, 0, 0.9);
                        display: block;
                        min-height: 70%;
                        font-family: Verdana;
                        max-width: 1100px;
                        background-color: #E8EDEE;
                        margin: auto;
                        margin-top: auto;
                        margin-right: auto;
                        margin-bottom: auto;
                        margin-left: auto;
                        white-space: pre-wrap;
                        border: none;
                        box-sizing: border-box;
                        color: #2D0D0D;
                        line-height: 1.1;
                        padding: 4.7em;                    }
                    .hint {
                        border-radius: 4px;
                        overflow: hidden;
                        box-shadow: 0 9px 9px rgba(0, 0, 0, 0.9);
                        display: block;
                        min-height: 100%;             
                        max-width: 1000px;
                        background-color: #E9E3B9;
                        margin: auto;
                        margin-top: auto;
                        margin-right: auto;
                        margin-bottom: auto;
                        margin-left: auto;
                        line-height: 1.1;
                        padding: 1.7em;                    }                    .home {
                        margin: 1.5em 0;
                        
                    }                    h1 {
                        color: #867452;
                        font-size: 60px;
                    }                    h2 {
                        color: #867452;
                        font-size: 40px;
                    }
                    
                    h3 {
                        color: #867452;
                        font-size: 30px;
                    }

                    h4 {
                        color: #867452;
                        font-size: 25px;
                    }

                    .it, .listit {
                        color: brown;
                        font-size: 24px;
                        font-style: italic;
                        letter-spacing: 0.04em;
                    }
                    .p, .listitem {
                        color: #75AFAD;
                        font-size: 24px;
                        font-style: italic;
                        letter-spacing: 0.04em;
                    }                    pre {display: block;
                    font-family: monospace;
                    white-space: pre;
                    margin: 1em 0;
                    font-size: 16px
                    }                    code
                    {margin: auto,
                        font-family:"Lucida Console";
                        "Andale Mono";
                        "Courier New";
                        Courier;
                        monospace;
                        font-style:normal;
                        color:#395C73;}
                    
                    code strong
                    {color:#000;
                        background:#F5FD11;
                        padding:1px;
                        font-weight:normal;
                    }                    .interno {
                    font-family: verdana;
                    font-style: italic;
                    color: #395C73;
                    font-size: 24px;    
                    }                    .sub{
                        text-decoration: underline;
                    }
                `}</style>
<div className="col-md-6">
<header class="entry-header">  <h2>The introduction to Reactive Programming you've been missing</h2>
</header><p className="p">(by <a href="https://twitter.com/andrestaltz">@andrestaltz</a>)</p>
<h3>This tutorial as a series of videos</h3><p className="it"><strong>Si prefiere ver tutoriales de vídeo en directo con la codificación, a continuación, echa un vistazo a esta serie he grabado con el mismo contenido que en este artículo: <a href="https://egghead.io/series/introduction-to-reactive-programming">Egghead.io - Introducción a la programación reactiva</a> .</strong></p>
<p className="p"><strong>If you prefer to watch video tutorials with live-coding, then check out this series I recorded with the same contents as in this article: <a href="https://egghead.io/series/introduction-to-reactive-programming">Egghead.io - Introduction to Reactive Programming</a>.</strong></p><p className="it">Así que usted es curioso en el aprendizaje de esta nueva cosa llamada programación reactiva, particularmente su variante comprende de Rx, Bacon.js, el RAC, y otros.</p>
<p className="p">So you're curious in learning this new thing called Reactive Programming, particularly its variant comprising of Rx, Bacon.js, RAC, and others.</p>
<p className="it">El aprendizaje es difícil, aún más difícil por la falta de un buen material. Cuando empecé, he intentado buscar tutoriales. He encontrado sólo un puñado de guías prácticas, pero que sólo arañado la superficie y nunca abordó el desafío de construir toda la arquitectura alrededor de ella. documentación de la biblioteca a menudo no ayudan cuando estás tratando de entender alguna función. Quiero decir, honestamente, mira esto:</p>
<p className="p">Learning it is hard, even harder by the lack of good material. When I started, I tried looking for tutorials. I found only a handful of practical guides, but they just scratched the surface and never tackled the challenge of building the whole architecture around it. Library documentations often don't help when you're trying to understand some function. I mean, honestly, look at this:</p><blockquote><p className="it"><strong>Rx.Observable.prototype.flatMapLatest (selector, [thisArg])</strong></p>
<p className="p"><strong>Rx.Observable.prototype.flatMapLatest(selector, [thisArg])</strong></p></blockquote>
<blockquote><p className="it">Proyecta cada elemento de una secuencia observable en una nueva secuencia de las secuencias de observables mediante la incorporación de índice del elemento y luego transforma una secuencia observable de secuencias observables en una producción de la secuencia observables sólo valores de la secuencia observable más reciente.</p>
<p className="p">Projects each element of an observable sequence into a new sequence of observable sequences by incorporating the element's index and then transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.</p></blockquote><p className="it">vaca sagrada.</p>
<p className="p">Holy cow.</p>
<p className="it">He leído dos libros, uno simplemente pintado el cuadro grande, mientras que el otro se sumergió en el uso de la biblioteca reactiva. Terminé el aprendizaje de programación reactiva de la manera difícil: averiguarlo mientras que la construcción de la misma. En mi trabajo en <a href="https://www.futurice.com">Futurice</a> tengo que usarlo en un proyecto real, y tuvo el <a href="http://blog.futurice.com/top-7-tips-for-rxjava-on-android">apoyo de algunos colegas</a> cuando me encontré con problemas.</p>
<p className="p">I've read two books, one just painted the big picture, while the other dived into how to use the Reactive library. I ended up learning Reactive Programming the hard way: figuring it out while building with it. At my work in <a href="https://www.futurice.com">Futurice</a> I got to use it in a real project, and had the <a href="http://blog.futurice.com/top-7-tips-for-rxjava-on-android">support of some colleagues</a> when I ran into troubles.</p>
<p className="it">La parte más difícil del viaje de aprendizaje está <strong>pensando en reactiva</strong> . Es mucho acerca de dejar de lado los viejos hábitos imperativas y con estado de la programación típica, y obligando a su cerebro a trabajar en un paradigma diferente. No he encontrado ninguna guía en Internet, en este aspecto, y creo que el mundo se merece un tutorial práctico sobre cómo pensar en reactiva, de manera que se puede empezar. Documentación de la biblioteca puede iluminar su camino después de eso. Espero que esto te ayude.</p>
<p className="p">The hardest part of the learning journey is <strong>thinking in Reactive</strong>. It's a lot about letting go of old imperative and stateful habits of typical programming, and forcing your brain to work in a different paradigm. I haven't found any guide on the internet in this aspect, and I think the world deserves a practical tutorial on how to think in Reactive, so that you can get started. Library documentation can light your way after that. I hope this helps you.</p><h2>"What is Reactive Programming?"</h2><p className="it">Hay un montón de malas explicaciones y definiciones que hay en internet. <a href="https://en.wikipedia.org/wiki/Reactive_programming">Wikipedia</a> es demasiado genérico y teórica como de costumbre. <a href="http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming">Stackoverflow</a> respuesta canónica 's, obviamente no es adecuado para los recién llegados. <a href="http://www.reactivemanifesto.org/">Manifiesto reactiva</a> suena como el tipo de cosa que usted muestra a su jefe de proyecto o de los hombres de negocios en su empresa. De Microsoft <a href="https://rx.codeplex.com/">terminología Rx</a> "Rx = observables + LINQ + programadores" es tan pesado y Microsoftish que la mayoría de nosotros se quedan confundidos. Términos como "reactivo" y "propagación de cambio" no transmiten nada específicamente diferente a lo que ya lo hace su MV * y el favorito lenguaje típico. Por supuesto mis puntos de vista marco reaccionan a los modelos. Por supuesto cambio se propaga. Si no lo sería, nada quedaría.</p>
<p className="p">There are plenty of bad explanations and definitions out there on the internet. <a href="https://en.wikipedia.org/wiki/Reactive_programming">Wikipedia</a> is too generic and theoretical as usual. <a href="http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming">Stackoverflow</a>'s canonical answer is obviously not suitable for newcomers. <a href="http://www.reactivemanifesto.org/">Reactive Manifesto</a> sounds like the kind of thing you show to your project manager or the businessmen at your company. Microsoft's <a href="https://rx.codeplex.com/">Rx terminology</a> "Rx = Observables + LINQ + Schedulers" is so heavy and Microsoftish that most of us are left confused. Terms like "reactive" and "propagation of change" don't convey anything specifically different to what your typical MV* and favorite language already does. Of course my framework views react to the models. Of course change is propagated. If it wouldn't, nothing would be rendered.</p>
<p className="it">Así que vamos a cortar la mierda.</p>
<p className="p">So let's cut the bullshit.</p><h4>Reactive programming is programming with asynchronous data streams.</h4><p className="it">En cierto modo, esto no es nada nuevo. autobuses evento o los eventos típicos de clic son realmente un flujo de eventos asíncronos, en la que se puede observar y hacer algunos efectos secundarios. Reactiva es esa idea en los esteroides. Usted es capaz de crear flujos de datos de cualquier cosa, no sólo de clic y flotar eventos. Corrientes son baratos y ubicua, cualquier cosa puede ser una corriente: las variables, las entradas del usuario, propiedades, cachés, estructuras de datos, etc. Por ejemplo, imagine que su cuenta de Twitter sería un flujo de datos de la misma manera que haga clic en eventos son. Se puede escuchar a esa corriente y reaccionar en consecuencia.</p>
<p className="p">In a way, this isn't anything new. Event buses or your typical click events are really an asynchronous event stream, on which you can observe and do some side effects. Reactive is that idea on steroids. You are able to create data streams of anything, not just from click and hover events. Streams are cheap and ubiquitous, anything can be a stream: variables, user inputs, properties, caches, data structures, etc. For example, imagine your Twitter feed would be a data stream in the same fashion that click events are. You can listen to that stream and react accordingly.</p>
<p className="it"><strong>Además de eso, se le da una increíble caja de herramientas de funciones para combinar, crear y filtrar cualquiera de esas corrientes. </strong>Ahí es donde las patadas mágicas "funcionales" en. Una corriente se pueden utilizar como una entrada a otra. Incluso los múltiples flujos se pueden utilizar como entradas a otra corriente. Puede <em>combinar</em> dos corrientes. Puede <em>filtrar</em> un flujo de conseguir otro que tiene sólo aquellos eventos que le interesan. Puede <em>asignar</em> valores de datos de una secuencia a otra nueva.</p>
<p className="p"><strong>On top of that, you are given an amazing toolbox of functions to combine, create and filter any of those streams.</strong> That's where the "functional" magic kicks in. A stream can be used as an input to another one. Even multiple streams can be used as inputs to another stream. You can <em>merge</em> two streams. You can <em>filter</em> a stream to get another one that has only those events you are interested in. You can <em>map</em> data values from one stream to another new one.</p>
<p className="it">Si las corrientes son tan importantes para reactiva, vamos a echar una mirada cuidadosa a ellos, comenzando con nuestros "hace clic en un botón de" familiares flujo de eventos.</p>
<p className="p">If streams are so central to Reactive, let's take a careful look at them, starting with our familiar "clicks on a button" event stream.</p>
<p className="p"><a href="https://camo.githubusercontent.com/36c0a9ffd8ed22236bd6237d44a1d3eecbaec336/687474703a2f2f692e696d6775722e636f6d2f634c344d4f73532e706e67" target="_blank"><img src="https://camo.githubusercontent.com/36c0a9ffd8ed22236bd6237d44a1d3eecbaec336/687474703a2f2f692e696d6775722e636f6d2f634c344d4f73532e706e67" alt="Click event stream" data-canonical-src="http://i.imgur.com/cL4MOsS.png"/></a></p>
<p className="it">Una corriente es una secuencia de <strong>acontecimientos en curso ordenados en el tiempo</strong> . Se puede emitir tres cosas diferentes: un valor (de algún tipo), de un error, o una señal de "completado". Considere que el "completado" se lleva a cabo, por ejemplo, cuando la ventana o vista que contiene ese botón actual está cerrado.</p>
<p className="p">A stream is a sequence of <strong>ongoing events ordered in time</strong>. It can emit three different things: a value (of some type), an error, or a "completed" signal. Consider that the "completed" takes place, for instance, when the current window or view containing that button is closed.</p>
<p className="it">Capturamos estos eventos emitidos solamente <strong>de forma asíncrona</strong> , mediante la definición de una función que se ejecutará cuando se emite un valor, otra función cuando se emite un error, y otra función cuando 'completado' se emite. A veces, estos dos últimos pueden ser omitidas y sólo puede centrarse en la definición de la función de los valores. El "escuchar" a la corriente que se llama <strong>suscripción</strong> . Las funciones que están definiendo son observadores. La corriente es el sujeto (o "observable") siendo observado. Este es precisamente el <a href="https://en.wikipedia.org/wiki/Observer_pattern">diseño del modelo de observador</a> .</p>
<p className="p">We capture these emitted events only <strong>asynchronously</strong>, by defining a function that will execute when a value is emitted, another function when an error is emitted, and another function when 'completed' is emitted. Sometimes these last two can be omitted and you can just focus on defining the function for values. The "listening" to the stream is called <strong>subscribing</strong>. The functions we are defining are observers. The stream is the subject (or "observable") being observed. This is precisely the <a href="https://en.wikipedia.org/wiki/Observer_pattern">Observer Design Pattern</a>.</p>
<p className="it">Una forma alternativa de dibujo que es diagrama con ASCII, que vamos a utilizar en algunas partes de este tutorial:</p>
<p className="p">An alternative way of drawing that diagram is with ASCII, which we will use in some parts of this tutorial:</p>


<div>codigo098</div>


<p className="it">Dado que esto se siente tan familiar ya, y no quiero que te aburras, vamos a hacer algo nuevo: vamos a crear nuevos flujos de eventos transformados clic fuera de la corriente clic evento original.</p>
<p className="p">Since this feels so familiar already, and I don't want you to get bored, let's do something new: we are going to create new click event streams transformed out of the original click event stream.</p>
<p className="it">En primer lugar, vamos a hacer un flujo de contador que indica el número de veces que se hace clic en un botón. En las bibliotecas reactivas comunes, cada corriente tiene muchas funciones que se le atribuye, como por ejemplo <code>map</code>, <code>filter</code>, <code>scan</code>, etc. Cuando se llama a una de estas funciones, como por ejemplo <code>clickStream.map(f)</code>, devuelve un <strong>nuevo flujo</strong> basado en la corriente clic. No modifica la corriente de metrónomo original de ninguna manera. Esta es una propiedad llamada <strong>inmutabilidad</strong> , y que va de la mano con las corrientes reactivas al igual que panqueques son buenos con el jarabe. Que nos permite funciones de la cadena como <code>clickStream.map(f).scan(g)</code>:</p>
<p className="p">First, let's make a counter stream that indicates how many times a button was clicked. In common Reactive libraries, each stream has many functions attached to it, such as <code>map</code>, <code>filter</code>, <code>scan</code>, etc. When you call one of these functions, such as <code>clickStream.map(f)</code>, it returns a <strong>new stream</strong> based on the click stream. It does not modify the original click stream in any way. This is a property called <strong>immutability</strong>, and it goes together with Reactive streams just like pancakes are good with syrup. That allows us to chain functions like <code>clickStream.map(f).scan(g)</code>:</p>


<div>codigo099</div>


<p className="it">La <code>map(f)</code>función sustituye (en la nueva corriente) cada valor emitido de acuerdo con una función <code>f</code>que proporcione. En nuestro caso, hemos mapeado al número 1 en cada clic. La <code>scan(g)</code>función de los agregados de todos los valores anteriores de la corriente, que produce valor <code>x = g(accumulated, current)</code>, cuando <code>g</code>era simplemente la función de complemento en este ejemplo. A continuación, <code>counterStream</code>emite el número total de clics cada vez que una pulsación se produce.</p>
<p className="p">The <code>map(f)</code> function replaces (into the new stream) each emitted value according to a function <code>f</code> you provide. In our case, we mapped to the number 1 on each click. The <code>scan(g)</code> function aggregates all previous values on the stream, producing value <code>x = g(accumulated, current)</code>, where <code>g</code> was simply the add function in this example. Then, <code>counterStream</code> emits the total number of clicks whenever a click happens.</p>
<p className="it">Para mostrar el poder real de reactivo, digamos que usted quiere tener un flujo de eventos "doble clic". Para hacerlo aún más interesante, digamos que queremos que el nuevo flujo de considerar clics triples como hacer doble clic, o en general, varios clics (dos o más). Tome una respiración profunda y imaginar lo que haría que de manera imperativa y con estado tradicional. Estoy seguro que suena bastante desagradable e implica algunas variables para mantener el estado y algunos jugando con intervalos de tiempo.</p>
<p className="p">To show the real power of Reactive, let's just say that you want to have a stream of "double click" events. To make it even more interesting, let's say we want the new stream to consider triple clicks as double clicks, or in general, multiple clicks (two or more). Take a deep breath and imagine how you would do that in a traditional imperative and stateful fashion. I bet it sounds fairly nasty and involves some variables to keep state and some fiddling with time intervals.</p>
<p className="it">Pues bien, en reactiva es bastante simple. De hecho, la lógica está a sólo <a href="http://jsfiddle.net/staltz/4gGgs/27/">4 líneas de código</a> . Pero vamos a ignorar código por ahora. Pensando en los diagramas es la mejor manera de entender y construir corrientes, si usted es un principiante o un experto.</p>
<p className="p">Well, in Reactive it's pretty simple. In fact, the logic is just <a href="http://jsfiddle.net/staltz/4gGgs/27/">4 lines of code</a>.
But let's ignore code for now. Thinking in diagrams is the best way to understand and build streams, whether you're a beginner or an expert.</p>
<p className="p"><a href="https://camo.githubusercontent.com/995c301de2f566db10748042a5a67cc5d9ac45d9/687474703a2f2f692e696d6775722e636f6d2f484d47574e4f352e706e67" target="_blank"><img src="https://camo.githubusercontent.com/995c301de2f566db10748042a5a67cc5d9ac45d9/687474703a2f2f692e696d6775722e636f6d2f484d47574e4f352e706e67" alt="Multiple clicks stream" data-canonical-src="http://i.imgur.com/HMGWNO5.png" /></a></p>
<p className="it">Los recuadros grises son funciones que transforman una corriente a otra. En primer lugar vamos acumulando clics en las listas, cada vez que ha sucedido 250 milisegundos de "silencio evento" (eso es lo que <code>buffer(stream.throttle(250ms))</code>hace, en pocas palabras. No se preocupe por la comprensión de los detalles en este momento, sólo estamos haciendo una demostración reactiva por ahora). El resultado es una corriente de listas, de que aplicamos <code>map()</code>para mapear cada lista a un número entero búsqueda de la longitud de esa lista. Por último, hacemos caso de <code>1</code>números enteros utilizando la <code>filter(x &gt;= 2)</code>función. Eso es todo: 3 operaciones para producir nuestro flujo previsto. Entonces podemos suscribir ( "escuchar") a ella a reaccionar en consecuencia cómo deseamos.</p>
<p className="p">Grey boxes are functions transforming one stream into another. First we accumulate clicks in lists, whenever 250 milliseconds of "event silence" has happened (that's what <code>buffer(stream.throttle(250ms))</code> does, in a nutshell. Don't worry about understanding the details at this point, we are just demoing Reactive for now). The result is a stream of lists, from which we apply <code>map()</code> to map each list to an integer matching the length of that list. Finally, we ignore <code>1</code> integers using the <code>filter(x &gt;= 2)</code> function. That's it: 3 operations to produce our intended stream. We can then subscribe ("listen") to it to react accordingly how we wish.</p>
<p className="it">Espero que disfruten de la belleza de este enfoque. Este ejemplo es sólo la punta del iceberg: se pueden aplicar las mismas operaciones en diferentes tipos de corrientes, por ejemplo, en una corriente de respuestas del API; Por otro lado, hay muchas otras funciones disponibles.</p>
<p className="p">I hope you enjoy the beauty of this approach. This example is just the tip of the iceberg: you can apply the same operations on different kinds of streams, for instance, on a stream of API responses; on the other hand, there are many other functions available.</p>


<h2>"Why should I consider adopting RP?"</h2>


<p className="it">Programación reactiva eleva el nivel de abstracción de su código para que pueda centrarse en la interdependencia de los eventos que definen la lógica de negocio, en lugar de tener que jugar constantemente con una gran cantidad de detalles de implementación. Código de RP es probable que sea más conciso.</p>
<p className="p">Reactive Programming raises the level of abstraction of your code so you can focus on the interdependence of events that define the business logic, rather than having to constantly fiddle with a large amount of implementation details. Code in RP will likely be more concise.</p>
<p className="it">El beneficio es más evidente en las aplicaciones web modernas y aplicaciones móviles que son altamente interactivo con una multitud de eventos de interfaz de usuario relacionados con eventos de datos. Hace 10 años, la interacción con las páginas web era básicamente sobre el envío de una forma mucho al backend y realizar la representación simple de la interfaz. Aplicaciones han evolucionado para ser más en tiempo real: la modificación de un único campo de formulario puede desencadenar automáticamente una operación de salvar al backend, "me gusta" a algún contenido se puede reflejar en tiempo real con otros usuarios conectados, y así sucesivamente.</p>
<p className="p">The benefit is more evident in modern webapps and mobile apps that are highly interactive with a multitude of UI events related to data events. 10 years ago, interaction with web pages was basically about submitting a long form to the backend and performing simple rendering to the frontend. Apps have evolved to be more real-time: modifying a single form field can automatically trigger a save to the backend, "likes" to some content can be reflected in real time to other connected users, and so forth.</p>
<p className="it">Aplicaciones hoy en día tienen una abundancy de eventos en tiempo real de todo tipo que permiten una experiencia altamente interactiva para el usuario. Necesitamos herramientas para tratar adecuadamente con eso, y programación reactiva es una respuesta.</p>
<p className="p">Apps nowadays have an abundancy of real-time events of every kind that enable a highly interactive experience to the user. We need tools for properly dealing with that, and Reactive Programming is an answer.</p><h2>Thinking in RP, with examples</h2><p className="it">Vamos a bucear en las cosas reales. Un ejemplo del mundo real con una guía paso a paso sobre cómo pensar en RP. No hay ejemplos sintéticos, no hay conceptos medio-explicado. Al final de este tutorial habremos producido código de funcionamiento real, mientras que saber por qué lo hicimos cada cosa.</p>
<p className="p">Let's dive into the real stuff. A real-world example with a step-by-step guide on how to think in RP. No synthetic examples, no half-explained concepts. By the end of this tutorial we will have produced real functioning code, while knowing why we did each thing.</p>
<p className="it">Cogí <strong>JavaScript</strong> y <strong><a href="https://github.com/Reactive-Extensions/RxJS">RxJS</a></strong> como las herramientas para esto, por una razón: JavaScript es el lenguaje más familiar que hay en este momento, y el <a href="http://www.reactivex.io">* familia biblioteca Rx</a> está ampliamente disponible para muchos idiomas y plataformas ( <a href="https://rx.codeplex.com/">.NET</a> , <a href="https://github.com/Netflix/RxJava">Java</a> , <a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-scala">Scala</a> , <a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-clojure">Clojure</a> ,   <a href="https://github.com/Reactive-Extensions/RxJS">JavaScript</a> , <a href="https://github.com/Reactive-Extensions/Rx.rb">Rubí</a> , <a href="https://github.com/Reactive-Extensions/RxPy">Python</a> , <a href="https://github.com/Reactive-Extensions/RxCpp">C ++</a> , <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">Objective-C / Cocoa</a> , <a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-groovy">maravilloso</a> , etc). Sean cuales sean sus herramientas son, usted puede beneficiarse concretamente siguiendo este tutorial.</p>
<p className="p">I picked <strong>JavaScript</strong> and <strong><a href="https://github.com/Reactive-Extensions/RxJS">RxJS</a></strong> as the tools for this, for a reason: JavaScript is the most familiar language out there at the moment, and the <a href="http://www.reactivex.io">Rx* library family</a> is widely available for many languages and platforms (<a href="https://rx.codeplex.com/">.NET</a>, <a href="https://github.com/Netflix/RxJava">Java</a>, <a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-scala">Scala</a>, <a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-clojure">Clojure</a>,  <a href="https://github.com/Reactive-Extensions/RxJS">JavaScript</a>, <a href="https://github.com/Reactive-Extensions/Rx.rb">Ruby</a>, <a href="https://github.com/Reactive-Extensions/RxPy">Python</a>, <a href="https://github.com/Reactive-Extensions/RxCpp">C++</a>, <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">Objective-C/Cocoa</a>, <a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-groovy">Groovy</a>, etc). So whatever your tools are, you can concretely benefit by following this tutorial.</p><h2>Implementing a "Who to follow" suggestions box</h2><p className="it">En Twitter hay este elemento de interfaz de usuario que sugiere otras cuentas que podría seguir:</p>
<p className="p">In Twitter there is this UI element that suggests other accounts you could follow:</p>
<p className="p"><a href="https://camo.githubusercontent.com/81e5d63c69768e1b04447d2e246f47540dd83fbd/687474703a2f2f692e696d6775722e636f6d2f65416c4e62306a2e706e67" target="_blank"><img src="https://camo.githubusercontent.com/81e5d63c69768e1b04447d2e246f47540dd83fbd/687474703a2f2f692e696d6775722e636f6d2f65416c4e62306a2e706e67" alt="Twitter Who to follow suggestions box" data-canonical-src="http://i.imgur.com/eAlNb0j.png" /></a></p>
<p className="it">Nos vamos a centrar en la imitación de sus características principales, que son:</p>
<p className="p">We are going to focus on imitating its core features, which are:</p><ul>
<li className="it"> Al arrancar, cargue los datos de cuentas de la API y muestre 3 sugerencias </li>
<li className="p">On startup, load accounts data from the API and display 3 suggestions</li>
<li className="it"> Al hacer clic en "Actualizar", cargue otras 3 sugerencias de cuenta en las 3 filas </li>
<li className="p">On clicking "Refresh", load 3 other account suggestions into the 3 rows</li>
<li className="it"> Al hacer clic en el botón "x" de una fila de la cuenta, borre sólo la cuenta actual y mostrará otra </li>
<li className="p">On click 'x' button on an account row, clear only that current account and display another</li>
<li className="it"> Cada fila muestra el avatar de la cuenta y los enlaces a su página </li>
<li className="p">Each row displays the account's avatar and links to their page</li>
</ul><p className="it">Podemos dejar de lado las otras funciones y botones, ya que son de menor importancia. Y, en lugar de Twitter, que recientemente cerró su API para el público no autorizado, vamos a construir esa interfaz de usuario para seguir a la gente en Github. Hay una <a href="https://developer.github.com/v3/users/#get-all-users">API de Github para conseguir usuarios</a> .</p>
<p className="p">We can leave out the other features and buttons because they are minor. And, instead of Twitter, which recently closed its API to the unauthorized public, let's build that UI for following people on Github. There's a <a href="https://developer.github.com/v3/users/#get-all-users">Github API for getting users</a>.</p>
<p className="it">El código completo de este está listo en <a href="http://jsfiddle.net/staltz/8jFJH/48/">http://jsfiddle.net/staltz/8jFJH/48/</a> en caso de que quiera tener un pico ya.</p>
<p className="p">The complete code for this is ready at <a href="http://jsfiddle.net/staltz/8jFJH/48/">http://jsfiddle.net/staltz/8jFJH/48/</a> in case you want to take a peak already.</p><h2><a id="user-content-request-and-response" class="anchor" href="#request-and-response" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Request and response</h2><p className="it"><strong>¿Cómo se aborda este problema con Rx? </strong>Bueno, para empezar, (casi) <em>todo puede ser una corriente</em> . Ese es el mantra Rx. Vamos a empezar con la característica más fácil: "en la puesta en marcha, la carga 3 cuentas de datos de la API". No hay nada especial aquí, esto es simplemente acerca de (1) hacer una petición, (2) obtener una respuesta, (3) la representación de la respuesta. Así que vamos a seguir adelante y representan nuestras peticiones como una corriente. Al principio esto se sentirá como una exageración, pero tenemos que empezar desde lo básico, ¿verdad?</p>
<p className="p"><strong>How do you approach this problem with Rx?</strong> Well, to start with, (almost) <em>everything can be a stream</em>. That's the Rx mantra. Let's start with the easiest feature: "on startup, load 3 accounts data from the API". There is nothing special here, this is simply about (1) doing a request, (2) getting a response, (3) rendering the response. So let's go ahead and represent our requests as a stream. At first this will feel like overkill, but we need to start from the basics, right?</p>
<p className="it">En el inicio tenemos que hacer una única petición, por lo que si se modela como un flujo de datos, que será una corriente con un único valor emitido. Más tarde, sabemos que vamos a tener muchas solicitudes pasando, pero por ahora, es sólo uno.</p>
<p className="p">On startup we need to do only one request, so if we model it as a data stream, it will be a stream with only one emitted value. Later, we know we will have many requests happening, but for now, it is just one.</p>

<div class="highlight highlight-source-js">codigo100</div>
<p className="it">Se trata de una corriente de direcciones URL que queremos pedir. Cada vez que un evento de solicitud que pase, nos dice dos cosas: cuándo y qué. "Cuando" la solicitud debe ser ejecutado es cuando se emite el evento. Y "lo que" debe ser solicitada es el valor emitido: una cadena que contiene la dirección URL.</p>
<p className="p">This is a stream of URLs that we want to request. Whenever a request event happens, it tells us two things: when and what. "When" the request should be executed is when the event is emitted. And "what" should be requested is the value emitted: a string containing the URL.</p>
<p className="it">Para crear dicha corriente con un único valor es muy simple en Rx *. La terminología oficial para un flujo es "observable", por el hecho de que se puede observar, pero me parece que sea un nombre tonto, así que llamamos <em>corriente</em> .</p>
<p className="p">To create such stream with a single value is very simple in Rx*. The official terminology for a stream is "Observable", for the fact that it can be observed, but I find it to be a silly name, so I call it <em>stream</em>.</p>

<div class="highlight highlight-source-js">codigo1</div>
<p className="it">Pero ahora, eso es sólo una corriente de cuerdas, haciendo ninguna otra operación, por lo que tenemos que hacer de alguna manera algo suceda cuando se emite ese valor. Eso se hace por <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypesubscribeobserver--onnext-onerror-oncompleted">suscribirse</a> a la corriente.</p>
<p className="p">But now, that is just a stream of strings, doing no other operation, so we need to somehow make something happen when that value is emitted. That's done by <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypesubscribeobserver--onnext-onerror-oncompleted">subscribing</a> to the stream.</p><div class="highlight highlight-source-js">codigo2</div><p className="it">Nótese que estamos utilizando una devolución de llamada Ajax jQuery (que se supone que <a href="http://devdocs.io/jquery/jquery.getjson">debe saber ya</a> ) para manejar la asincronía de la operación de petición. Pero espere un momento, Rx es para hacer frente a <strong>asíncronos</strong> flujos de datos. No podía la respuesta a esa solicitud sea una corriente que contiene los datos que llegan en algún momento en el futuro? Pues bien, a nivel conceptual, seguro que parece que, por lo que vamos a tratar.</p>
<p className="p">Notice we are using a jQuery Ajax callback (which we assume you <a href="http://devdocs.io/jquery/jquery.getjson">should know already</a>) to handle the asynchronicity of the request operation. But wait a moment, Rx is for dealing with <strong>asynchronous</strong> data streams. Couldn't the response for that request be a stream containing the data arriving at some time in the future? Well, at a conceptual level, it sure looks like it, so let's try that.</p><div class="highlight highlight-source-js">codigo3</div><p className="it">Lo que <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablecreatesubscribe"><code>Rx.Observable.create()</code></a>hace es crear su propio flujo de costumbre, informando de forma explícita cada observador (o en otras palabras, un "suscriptor") acerca de eventos de datos ( <code>onNext()</code>) o errores ( <code>onError()</code>). Lo que hicimos fue simplemente envolver que jQuery Ajax promesa. <strong>Disculpe, ¿significa esto que una promesa es un observable?</strong></p>
<p className="p">What <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablecreatesubscribe"><code>Rx.Observable.create()</code></a> does is create your own custom stream by explicitly informing each observer (or in other words, a "subscriber") about data events (<code>onNext()</code>) or errors (<code>onError()</code>). What we did was just wrap that jQuery Ajax Promise. <strong>Excuse me, does this mean that a Promise is an Observable?</strong></p>
<div class="highlight highlight-source-js">codigo0</div>
<p className="p"><a href="https://camo.githubusercontent.com/4df519edd2d527bf5e90b7d00e22cdc3c3be00d4/687474703a2f2f7777772e6d79666163657768656e2e6e65742f75706c6f6164732f333332342d616d617a65642d666163652e676966" target="_blank"><img src="https://camo.githubusercontent.com/4df519edd2d527bf5e90b7d00e22cdc3c3be00d4/687474703a2f2f7777772e6d79666163657768656e2e6e65742f75706c6f6164732f333332342d616d617a65642d666163652e676966" alt="Amazed" data-canonical-src="http://www.myfacewhen.net/uploads/3324-amazed-face.gif" /></a></p><p className="p">Yes.</p><p className="it">Observable es la promesa ++. En Rx se puede convertir fácilmente una promesa de un observable por hacer <code>var stream = Rx.Observable.fromPromise(promise)</code>, por lo que vamos a utilizar. La única diferencia es que no son observables <a href="http://promises-aplus.github.io/promises-spec/">Promesas / A +</a> compatible, pero conceptualmente no existe un choque. Una promesa es simplemente un observable con un valor emitido sola. Rx corrientes van más allá de las promesas al permitir que muchos valores devueltos.</p>
<p className="p">Observable is Promise++. In Rx you can easily convert a Promise to an Observable by doing <code>var stream = Rx.Observable.fromPromise(promise)</code>, so let's use that. The only difference is that Observables are not <a href="http://promises-aplus.github.io/promises-spec/">Promises/A+</a> compliant, but conceptually there is no clash. A Promise is simply an Observable with one single emitted value. Rx streams go beyond promises by allowing many returned values.</p>
<p className="it">Esto es bastante agradable, y muestra cómo observables son al menos tan potente como promesas. Así que si usted cree que el bombo promesas, mantener un ojo en lo que Rx observables son capaces de hacer.</p>
<p className="p">This is pretty nice, and shows how Observables are at least as powerful as Promises. So if you believe the Promises hype, keep an eye on what Rx Observables are capable of.</p>
<p className="it">Ahora, de vuelta a nuestro ejemplo, si usted no tardaron en darse cuenta, tenemos una <code>subscribe()</code>llamada dentro de otro, que es algo parecido al infierno de devolución de llamada. Además, la creación de <code>responseStream</code>depende <code>requestStream</code>. Como escucharon antes, en Rx existen mecanismos simples de transformación y la creación de nuevas fuentes de fuera de otros, por lo que deberían estar haciendo eso.</p>
<p className="p">Now back to our example, if you were quick to notice, we have one <code>subscribe()</code> call inside another, which is somewhat akin to callback hell. Also, the creation of <code>responseStream</code> is dependent on <code>requestStream</code>. As you heard before, in Rx there are simple mechanisms for transforming and creating new streams out of others, so we should be doing that.</p>
<p className="it">La única función básica que usted debe saber a estas alturas es decir <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypemapselector-thisarg"><code>map(f)</code></a>, que toma cada valor de corriente A, se aplica <code>f()</code>sobre ella, y produce un valor de corriente B. Si lo hacemos a nuestra solicitud y respuesta corrientes, podemos mapear direcciones URL de solicitud de respuesta promesas (disfrazados de corrientes).</p>
<p className="p">The one basic function that you should know by now is <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypemapselector-thisarg"><code>map(f)</code></a>, which takes each value of stream A, applies <code>f()</code> on it, and produces a value on stream B. If we do that to our request and response streams, we can map request URLs to response Promises (disguised as streams).</p><div class="highlight highlight-source-js">codigo4</div><p className="it">Entonces habremos creado una bestia llamada " <em>Metastream</em> ": una corriente de flujos. No se asuste todavía. A Metastream es una corriente donde cada valor emitido todavía es otra corriente. Se puede pensar en ello como <a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">punteros</a> : cada valor emitido es un <em>puntero</em> a otra corriente. En nuestro ejemplo, cada URL de solicitud se asigna a un puntero al flujo de la promesa que contiene la respuesta correspondiente.</p>
<p className="p">Then we will have created a beast called "<em>metastream</em>": a stream of streams. Don't panic yet. A metastream is a stream where each emitted value is yet another stream. You can think of it as <a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">pointers</a>: each emitted value is a <em>pointer</em> to another stream. In our example, each request URL is mapped to a pointer to the promise stream containing the corresponding response.</p>
<p className="p"><a href="https://camo.githubusercontent.com/2a8a9cc75acd13443f588fd7f386bd7a6dcb271a/687474703a2f2f692e696d6775722e636f6d2f48486e6d6c61632e706e67" target="_blank"><img src="https://camo.githubusercontent.com/2a8a9cc75acd13443f588fd7f386bd7a6dcb271a/687474703a2f2f692e696d6775722e636f6d2f48486e6d6c61632e706e67" alt="Response metastream" data-canonical-src="http://i.imgur.com/HHnmlac.png" /></a></p>
<p className="it">Un Metastream para las respuestas parece confuso, y no parece que nos ayude a todos. Sólo queremos una corriente sencilla de respuestas, donde cada valor emitido es un objeto JSON, no es una 'promesa' de un objeto JSON. Saludar a <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeflatmapselector-resultselector">Mr. Flatmap</a> : una versión de <code>map()</code>que "aplana" un Metastream, emitiendo en el "tronco" corriente de todo lo que se emitirá en las corrientes "rama". Flatmap no es una "solución" y metastreams no son un error, estos son realmente las herramientas para hacer frente a las respuestas asíncronas en Rx.</p>
<p className="p">A metastream for responses looks confusing, and doesn't seem to help us at all. We just want a simple stream of responses, where each emitted value is a JSON object, not a 'Promise' of a JSON object. Say hi to <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeflatmapselector-resultselector">Mr. Flatmap</a>: a version of <code>map()</code> that "flattens" a metastream, by emitting on the "trunk" stream everything that will be emitted on "branch" streams. Flatmap is not a "fix" and metastreams are not a bug, these are really the tools for dealing with asynchronous responses in Rx.</p><div class="highlight highlight-source-js">codigo5</div>
<p className="p"><a href="https://camo.githubusercontent.com/0b0ac4a249e1c15d7520c220957acfece1af3e95/687474703a2f2f692e696d6775722e636f6d2f4869337a4e7a4a2e706e67" target="_blank"><img src="https://camo.githubusercontent.com/0b0ac4a249e1c15d7520c220957acfece1af3e95/687474703a2f2f692e696d6775722e636f6d2f4869337a4e7a4a2e706e67" alt="Response stream" data-canonical-src="http://i.imgur.com/Hi3zNzJ.png" /></a></p>
<p className="it">Bonito. Y debido a que el flujo de respuesta se define de acuerdo con la petición de flujo, <strong>si</strong> tenemos más adelante más eventos que suceden en petición de flujo, tendremos los eventos que suceden en respuesta correspondientes secuencia de respuesta, como se esperaba:</p>
<p className="p">Nice. And because the response stream is defined according to request stream, <strong>if</strong> we have later on more events happening on request stream, we will have the corresponding response events happening on response stream, as expected:</p><div class="highlight highlight-source-js">codigo6</div><p className="it">Ahora que por fin tenemos una secuencia de respuesta, podemos hacer que los datos que recibimos:</p>
<p className="p">Now that we finally have a response stream, we can render the data we receive:</p><div class="highlight highlight-source-js">codigo7</div><p className="it">Uniendo todo el código hasta ahora, tenemos:</p>
<p className="p">Joining all the code until now, we have:</p><div class="highlight highlight-source-js">codigo8</div>
<h2><a id="user-content-the-refresh-button" class="anchor" href="#the-refresh-button" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The refresh button</h2><p className="it">Todavía no he mencionado que el JSON en la respuesta es una lista con 100 usuarios. La API sólo nos permite especificar el desplazamiento de página, y no el tamaño de la página, por lo que estamos utilizando sólo 3 objetos de datos y perder otros 97. Podemos ignorar el problema por ahora, ya que más adelante veremos cómo almacenar en caché las respuestas.</p>
<p className="p">I did not yet mention that the JSON in the response is a list with 100 users. The API only allows us to specify the page offset, and not the page size, so we're using just 3 data objects and wasting 97 others. We can ignore that problem for now, since later on we will see how to cache the responses.</p>
<p className="it">Cada vez que se hace clic en el botón de actualización, la corriente solicitud debe emitir una nueva dirección URL, por lo que podemos conseguir una nueva respuesta. Necesitamos dos cosas: una corriente de eventos de clic en el botón de actualización (mantra: cualquier cosa puede ser una corriente), y tenemos que cambiar la corriente de petición de depender de la corriente de refresco clic. Con mucho gusto, RxJS viene con herramientas para hacer observables de los detectores de eventos.</p>
<p className="p">Everytime the refresh button is clicked, the request stream should emit a new URL, so that we can get a new response. We need two things: a stream of click events on the refresh button (mantra: anything can be a stream), and we need to change the request stream to depend on the refresh click stream. Gladly, RxJS comes with tools to make Observables from event listeners.</p><div class="highlight highlight-source-js">codigo9</div><p className="it">Dado que el evento de actualización clic no efectúe por sí mismo cualquier URL de la API, hay que asignar cada clic a una URL real. Ahora cambiamos la corriente de petición de ser la corriente de refresco clic asignada al punto final de la API con un desplazamiento aleatorio parámetro cada vez.</p>
<p className="p">Since the refresh click event doesn't itself carry any API URL, we need to map each click to an actual URL. Now we change the request stream to be the refresh click stream mapped to the API endpoint with a random offset parameter each time.</p><div class="highlight highlight-source-js">codigo10</div><p className="it">Porque yo soy tonto y no tengo pruebas automatizadas, acabo de romper una de nuestras características construidas con anterioridad. Una solicitud no sucede más en el arranque, sucede sólo cuando se hace clic en el refresco. Urgh. Necesito ambos comportamientos: una solicitud cuando <em>sea</em> se hace clic en una actualización <em>o</em> la página web se acaba de abrir.</p>
<p className="p">Because I'm dumb and I don't have automated tests, I just broke one of our previously built features. A request doesn't happen anymore on startup, it happens only when the refresh is clicked. Urgh. I need both behaviors: a request when <em>either</em> a refresh is clicked <em>or</em> the webpage was just opened.</p>
<p className="it">Sabemos cómo hacer que una corriente separada para cada uno de esos casos:</p>
<p className="p">We know how to make a separate stream for each one of those cases:</p><div class="highlight highlight-source-js">codigo11</div><p className="it">Pero ¿cómo podemos "fusionar" estos dos en uno? Bueno, no <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypemergemaxconcurrent--other"><code>merge()</code></a>. Se explica en el dialecto diagrama, esto es lo que hace:</p>
<p className="p">But how can we "merge" these two into one? Well, there's <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypemergemaxconcurrent--other"><code>merge()</code></a>. Explained in the diagram dialect, this is what it does:</p>
<div class="highlight highlight-source-js">codigo12</div>
<p className="it">Debe ser fácil ahora:</p>
<p className="p">It should be easy now:</p><div class="highlight highlight-source-js">codigo13</div>
<p className="it">Hay una alternativa más limpia y la forma de escribir que, sin las corrientes intermedias.</p>
<p className="p">There is an alternative and cleaner way of writing that, without the intermediate streams.</p>
<div class="highlight highlight-source-js">codigo14</div>
<p className="it">Aún más corto, incluso más legible:</p>
<p className="p">Even shorter, even more readable:</p><div class="highlight highlight-source-js">codigo15</div>
<p className="it">La <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypestartwithscheduler-args"><code>startWith()</code></a>función hace exactamente lo que usted cree. No importa cómo su flujo de entrada parece, la corriente de salida resultante de <code>startWith(x)</code>tendrá <code>x</code>al principio. Pero no estoy <a href="https://en.wikipedia.org/wiki/Don't_repeat_yourself">seca</a> lo suficiente, estoy repitiendo la cadena API de punto final. Una forma de solucionar esto es moviendo la <code>startWith()</code>cerca de la <code>refreshClickStream</code>, esencialmente a "emular" una actualización clic en el arranque.</p>
<p className="p">The <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypestartwithscheduler-args"><code>startWith()</code></a> function does exactly what you think it does. No matter how your input stream looks like, the output stream resulting of <code>startWith(x)</code> will have <code>x</code> at the beginning. But I'm not <a href="https://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a> enough, I'm repeating the API endpoint string. One way to fix this is by moving the <code>startWith()</code> close to the <code>refreshClickStream</code>, to essentially "emulate" a refresh click on startup.</p><div class="highlight highlight-source-js">codigo16</div><p className="it">Bonito. Si usted va de nuevo a la punto en el que "rompió las pruebas automáticas", debería ver que la única diferencia con este último enfoque es que he añadido el <code>startWith()</code>.</p>
<p className="p">Nice. If you go back to the point where I "broke the automated tests", you should see that the only difference with this last approach is that I added the <code>startWith()</code>.</p><h2><a id="user-content-modelling-the-3-suggestions-with-streams" class="anchor" href="#modelling-the-3-suggestions-with-streams" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Modelling the 3 suggestions with streams</h2><p className="it">Hasta ahora, sólo hemos tocado una <em>sugerencia</em> elemento de interfaz de usuario en el paso de renderizado que sucede en el responseStream de <code>subscribe()</code>. Ahora, con el botón de actualización, tenemos un problema: tan pronto como se haga clic en 'Actualizar', los actuales 3 sugerencias no se borran. Nuevas sugerencias vienen en sólo después de una respuesta ha llegado, pero para que la interfaz de usuario se ven bien, tenemos que limpiar las sugerencias actuales cuando clics ocurren en la actualización.</p>
<p className="p">Until now, we have only touched a <em>suggestion</em> UI element on the rendering step that happens in the responseStream's <code>subscribe()</code>. Now with the refresh button, we have a problem: as soon as you click 'refresh', the current 3 suggestions are not cleared. New suggestions come in only after a response has arrived, but to make the UI look nice, we need to clean out the current suggestions when clicks happen on the refresh.</p><div class="highlight highlight-source-js">codigo17</div><p className="it">No, no tan rápido, amigo. Esto es malo, porque ahora tenemos <strong>dos</strong> abonados que afectan a los elementos sugerencia DOM (siendo el otro <code>responseStream.subscribe()</code>), y que en realidad no sonamos como <a href="https://en.wikipedia.org/wiki/Separation_of_concerns">separación de intereses</a> . Recuerde el mantra reactiva?</p>
<p className="p">No, not so fast, pal. This is bad, because we now have <strong>two</strong> subscribers that affect the suggestion DOM elements (the other one being <code>responseStream.subscribe()</code>), and that doesn't really sound like <a href="https://en.wikipedia.org/wiki/Separation_of_concerns">Separation of concerns</a>. Remember the Reactive mantra?</p>
<p className="p">&nbsp;
&nbsp;
&nbsp;
&nbsp;</p><p className="p"><a href="https://camo.githubusercontent.com/e581baffb3db3e4f749350326af32de8d5ba4363/687474703a2f2f692e696d6775722e636f6d2f4149696d5138432e6a7067" target="_blank"><img src="https://camo.githubusercontent.com/e581baffb3db3e4f749350326af32de8d5ba4363/687474703a2f2f692e696d6775722e636f6d2f4149696d5138432e6a7067" alt="Mantra" data-canonical-src="http://i.imgur.com/AIimQ8C.jpg" /></a></p>
<p className="it">Así que vamos a modelar una sugerencia como una corriente, donde cada valor emitido es el objeto JSON que contiene los datos de sugerencia. Lo haremos por separado para cada una de las 3 sugerencias. Así es como la corriente de sugerencia # 1 podría quedar así:</p>
<p className="p">So let's model a suggestion as a stream, where each emitted value is the JSON object containing the suggestion data. We will do this separately for each of the 3 suggestions. This is how the stream for suggestion #1 could look like:</p><div class="highlight highlight-source-js">codigo18</div><p className="it">Los otros, <code>suggestion2Stream</code>y <code>suggestion3Stream</code>pueden ser simplemente copiar pegar desde <code>suggestion1Stream</code>. Esto no es seco, pero mantendrá nuestro ejemplo simple para este tutorial, además creo que es un buen ejercicio para pensar cómo evitar la repetición en este caso.</p>
<p className="p">The others, <code>suggestion2Stream</code> and <code>suggestion3Stream</code> can be simply copy pasted from <code>suggestion1Stream</code>. This is not DRY, but it will keep our example simple for this tutorial, plus I think it's a good exercise to think how to avoid repetition in this case.</p>
<p className="it">En lugar de tener la prestación sucede en responseStream de suscribirse (), lo hacemos aquí:</p>
<p className="p">Instead of having the rendering happen in responseStream's subscribe(), we do that here:</p><div class="highlight highlight-source-js">codigo19</div><p className="it">Volver a la "en la actualización, desactive las sugerencias", podemos simplemente asignar clics de actualización a <code>null</code>los datos de sugerencia, y que lo incluya en el <code>suggestion1Stream</code>, tales como:</p>
<p className="p">Back to the "on refresh, clear the suggestions", we can simply map refresh clicks to <code>null</code> suggestion data, and include that in the <code>suggestion1Stream</code>, as such:</p><div class="highlight highlight-source-js">codigo20</div><p className="it">Y cuando la prestación, que interpretamos <code>null</code>como "sin datos", por lo tanto, ocultando su elemento de interfaz de usuario.</p>
<p className="p">And when rendering, we interpret <code>null</code> as "no data", hence hiding its UI element.</p><div class="highlight highlight-source-js">codigo21</div><p className="it">El panorama general es ahora:</p>
<p className="p">The big picture is now:</p><div class="highlight highlight-source-js">codigo22</div><p className="it">Donde <code>N</code>representa <code>null</code>.</p>
<p className="p">Where <code>N</code> stands for <code>null</code>.</p>
<p className="it">Como beneficio adicional, también podemos hacer sugerencias "vacíos" en el arranque. Esto se hace mediante la adición <code>startWith(null)</code>de las corrientes de sugerencias:</p>
<p className="p">As a bonus, we can also render "empty" suggestions on startup. That is done by adding <code>startWith(null)</code> to the suggestion streams:</p><div class="highlight highlight-source-js">codigo23</div><p className="it">Lo que resulta en:</p>
<p className="p">Which results in:</p>
<div class="highlight highlight-source-js">codigo24</div><h2><a id="user-content-closing-a-suggestion-and-using-cached-responses" class="anchor" href="#closing-a-suggestion-and-using-cached-responses" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Closing a suggestion and using cached responses</h2><p className="it">Hay una característica restante de implementar. Cada sugerencia debe tener su propio botón de 'x' para cerrarla, y la carga de otra en su lugar. A primera vista, se podría decir que es suficiente para hacer una nueva solicitud cuando se hace clic en cualquier botón de cierre:</p>
<p className="p">There is one feature remaining to implement. Each suggestion should have its own 'x' button for closing it, and loading another in its place. At first thought, you could say it's enough to make a new request when any close button is clicked:</p><div class="highlight highlight-source-js">codigo25</div><p className="it">Eso no funciona. Se va a cerrar y volver a cargar <em>todas las</em> sugerencias, en lugar de solamente el que hizo clic. Hay un par de diferentes maneras de resolver esto, y para mantenerlo interesante, vamos a resolverlo mediante la reutilización de las respuestas anteriores. Tamaño de página la respuesta del API es de 100 usuarios al mismo tiempo que estábamos usando sólo 3 de ellos, por lo que hay un montón de nuevos datos disponibles. No hay necesidad de pedir más.</p>
<p className="p">That does not work. It will close and reload <em>all</em> suggestions, rather than just only the one we clicked on. There are a couple of different ways of solving this, and to keep it interesting, we will solve it by reusing previous responses. The API's response page size is 100 users while we were using just 3 of those, so there is plenty of fresh data available. No need to request more.</p>
<p className="it">Una vez más, vamos a pensar en los arroyos. Cuando un evento de clic '' close1 sucede, queremos utilizar el <em>más reciente emitida</em> respuesta en <code>responseStream</code>conseguir un usuario al azar de la lista en la respuesta. Como tal:</p>
<p className="p">Again, let's think in streams. When a 'close1' click event happens, we want to use the <em>most recently emitted</em> response on <code>responseStream</code> to get one random user from the list in the response. As such:</p><div class="highlight highlight-source-js">codigo26</div>
<p className="it">En Rx * hay una función llamada combinador <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypecombinelatestargs-resultselector"><code>combineLatest</code></a>que parece hacer lo que necesitamos. Se necesitan dos corrientes A y B como entradas, y siempre que sea corriente emite un valor, <code>combineLatest</code>se une a los dos valores más recientemente emitidas <code>a</code>y <code>b</code>de las dos corrientes y da salida a un valor <code>c = f(x,y)</code>, donde <code>f</code>es una función definida. Es mejor se explica con un diagrama:</p>
<p className="p">In Rx* there is a combinator function called <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypecombinelatestargs-resultselector"><code>combineLatest</code></a> that seems to do what we need. It takes two streams A and B as inputs, and whenever either stream emits a value, <code>combineLatest</code> joins the two most recently emitted values <code>a</code> and <code>b</code> from both streams and outputs a value <code>c = f(x,y)</code>, where <code>f</code> is a function you define. It is better explained with a diagram:</p><div class="highlight highlight-source-js">codigo27</div><p className="it">Podemos aplicar combineLatest () en <code>close1ClickStream</code>y <code>responseStream</code>, por lo que cada vez que se hace clic en el botón de cierre 1, obtenemos la respuesta más reciente emitida y producir un nuevo valor en <code>suggestion1Stream</code>. Por otro lado, combineLatest () es simétrica: cada vez que una nueva respuesta se emite en <code>responseStream</code>, se combinará con la última 'cerrar 1' click para producir una nueva sugerencia. Eso es interesante, ya que nos permite simplificar nuestro código anterior para <code>suggestion1Stream</code>, de esta manera:</p>
<p className="p">We can apply combineLatest() on <code>close1ClickStream</code> and <code>responseStream</code>, so that whenever the close 1 button is clicked, we get the latest response emitted and produce a new value on <code>suggestion1Stream</code>. On the other hand, combineLatest() is symmetric: whenever a new response is emitted on <code>responseStream</code>, it will combine with the latest 'close 1' click to produce a new suggestion. That is interesting, because it allows us to simplify our previous code for <code>suggestion1Stream</code>, like this:</p><div class="highlight highlight-source-js">codigo28</div><p className="it">Una pieza que aún falta en el rompecabezas. El combineLatest () utiliza la más reciente de las dos fuentes, pero si una de esas fuentes no ha emitido nada todavía, combineLatest () no puede producir un evento de datos en la secuencia de salida. Si nos fijamos en el diagrama ASCII anterior, se verá que la salida no tiene nada cuando el primer flujo de valor emitido <code>a</code>. Sólo cuando el segundo flujo de valor emitido <code>b</code>podría producir un valor de salida.</p>
<p className="p">One piece is still missing in the puzzle. The combineLatest() uses the most recent of the two sources, but if one of those sources hasn't emitted anything yet, combineLatest() cannot produce a data event on the output stream. If you look at the ASCII diagram above, you will see that the output has nothing when the first stream emitted value <code>a</code>. Only when the second stream emitted value <code>b</code> could it produce an output value.</p>
<p className="it">Hay diferentes maneras de resolver esto, y que se quedará con la más simple, el cual se simula un clic con el botón 'cerrar 1' en el arranque:</p>
<p className="p">There are different ways of solving this, and we will stay with the simplest one, which is simulating a click to the 'close 1' button on startup:</p>
<div class="highlight highlight-source-js">codigo29</div><h2><a id="user-content-wrapping-up" class="anchor" href="#wrapping-up" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Wrapping up</h2><p className="it">Y ya hemos terminado. El código completo de todo esto fue la siguiente:</p>
<p className="p">And we're done. The complete code for all this was:</p><div class="highlight highlight-source-js">codigo30</div><p className="it"><strong>Se puede ver este ejemplo de trabajo en <a href="http://jsfiddle.net/staltz/8jFJH/48/">http://jsfiddle.net/staltz/8jFJH/48/</a></strong></p>
<p className="p"><strong>You can see this working example at <a href="http://jsfiddle.net/staltz/8jFJH/48/">http://jsfiddle.net/staltz/8jFJH/48/</a></strong></p>
<p className="it">Ese pedazo de código es pequeño pero denso: que cuenta con la gestión de múltiples eventos con la separación adecuada de las preocupaciones, e incluso el almacenamiento en caché de las respuestas. El estilo funcional hizo el código parezca más declarativa que imperativo: no estamos dando una secuencia de instrucciones a ejecutar, sólo estamos <strong>diciendo lo que algo es</strong> mediante la definición de las relaciones entre las corrientes. Por ejemplo, con Rx le dijimos al equipo que <em><code>suggestion1Stream</code> <strong>es</strong> el 'cierre 1' corriente combinada con un usuario de la última respuesta, además de ser <code>null</code>cuando una actualización sucede o sucedió el arranque del programa</em> .</p>
<p className="p">That piece of code is small but dense: it features management of multiple events with proper separation of concerns, and even caching of responses. The functional style made the code look more declarative than imperative: we are not giving a sequence of instructions to execute, we are just <strong>telling what something is</strong> by defining relationships between streams. For instance, with Rx we told the computer that <em><code>suggestion1Stream</code> <strong>is</strong> the 'close 1' stream combined with one user from the latest response, besides being <code>null</code> when a refresh happens or program startup happened</em>.</p>
<p className="it">Nótese también el impresionante ausencia de elementos de flujo de control, tales como <code>if</code>, <code>for</code>, <code>while</code>, y el flujo de control basado en devolución de llamada típico que se pueden esperar de una aplicación de JavaScript. Incluso puede deshacerse de la <code>if</code>y <code>else</code>en el <code>subscribe()</code>anterior usando <code>filter()</code>si quieres (Voy a dejar los detalles de implementación para usted como un ejercicio). En Rx, tenemos funciones de flujo, tales como <code>map</code>, <code>filter</code>, <code>scan</code>, <code>merge</code>, <code>combineLatest</code>, <code>startWith</code>, y muchos más para controlar el flujo de un programa orientado a eventos. Este conjunto de herramientas de funciones le da más poder en menos código.</p>
<p className="p">Notice also the impressive absence of control flow elements such as <code>if</code>, <code>for</code>, <code>while</code>, and the typical callback-based control flow that you expect from a JavaScript application. You can even get rid of the <code>if</code> and <code>else</code> in the <code>subscribe()</code> above by using <code>filter()</code> if you want (I'll leave the implementation details to you as an exercise). In Rx, we have stream functions such as <code>map</code>, <code>filter</code>, <code>scan</code>, <code>merge</code>, <code>combineLatest</code>, <code>startWith</code>, and many more to control the flow of an event-driven program. This toolset of functions gives you more power in less code.</p><h2><a id="user-content-what-comes-next" class="anchor" href="#what-comes-next" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What comes next</h2><p className="it">Si cree que Rx * será su biblioteca preferida para la programación reactiva, tomar un tiempo para familiarizarse con la <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md">gran lista de funciones</a> para la transformación, combinación y creando observables. Si se quiere entender esas funciones en los diagramas de flujos, echar un vistazo a <a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables">la documentación de gran utilidad RxJava con diagramas de mármol</a> . Siempre que te quedas atascado tratando de hacer algo, dibujar esos diagramas, pensar en ellos, mirar a la larga lista de funciones, y pensar más. Este flujo de trabajo ha sido eficaz en mi experiencia.</p>
<p className="p">If you think Rx* will be your preferred library for Reactive Programming, take a while to get acquainted with the <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md">big list of functions</a> for transforming, combining, and creating Observables. If you want to understand those functions in diagrams of streams, take a look at <a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables">RxJava's very useful documentation with marble diagrams</a>. Whenever you get stuck trying to do something, draw those diagrams, think on them, look at the long list of functions, and think more. This workflow has been effective in my experience.</p>
<p className="it">Una vez que comienza a recibir la caída de la programación con Rx *, que es absolutamente necesaria para entender el concepto de <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/creating.md#cold-vs-hot-observables">frío vs calientes observables</a> . Si hace caso omiso de esto, va a volver y morderte brutalmente. Usted ha sido advertido. Afilar sus habilidades adicionales mediante el aprendizaje de programación funcional real, y familiarizarse con cuestiones tales como los efectos secundarios que afectan Rx *.</p>
<p className="p">Once you start getting the hang of programming with Rx*, it is absolutely required to understand the concept of <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/creating.md#cold-vs-hot-observables">Cold vs Hot Observables</a>. If you ignore this, it will come back and bite you brutally. You have been warned. Sharpen your skills further by learning real functional programming, and getting acquainted with issues such as side effects that affect Rx*.</p>
<p className="it">Pero programación reactiva no es sólo Rx *. Hay <a href="http://baconjs.github.io/">Bacon.js</a> que es intuitiva para trabajar con, y sin las peculiaridades que a veces encontrar en la Rx *. El <a href="http://elm-lang.org/">Elm Idioma</a> vive en su propia categoría: se trata de una programación funcional reactivo <strong>lenguaje</strong> que compila a JavaScript + HTML + CSS, y cuenta con un <a href="http://debug.elm-lang.org/">depurador de tiempo de viaje</a> . Bastante impresionante.</p>
<p className="p">But Reactive Programming is not just Rx*. There is <a href="http://baconjs.github.io/">Bacon.js</a> which is intuitive to work with, without the quirks you sometimes encounter in Rx*. The <a href="http://elm-lang.org/">Elm Language</a> lives in its own category: it's a Functional Reactive Programming <strong>language</strong> that compiles to JavaScript + HTML + CSS, and features a <a href="http://debug.elm-lang.org/">time travelling debugger</a>. Pretty awesome.</p>
<p className="it">Rx funciona muy bien para interfaces y aplicaciones de eventos-pesado. Pero no es sólo una cosa del lado del cliente, funciona muy bien también en el backend y cerca de las bases de datos. De hecho, <a href="http://techblog.netflix.com/2013/02/rxjava-netflix-api.html">RxJava es un componente clave para que la concurrencia del lado del servidor en la API de Netflix</a> . Rx no es un marco restringido a un tipo específico de aplicación o lenguaje. Realmente es un paradigma que se puede utilizar en la programación de cualquier software orientado a eventos.</p>
<p className="p">Rx works great for event-heavy frontends and apps. But it is not just a client-side thing, it works great also in the backend and close to databases. In fact, <a href="http://techblog.netflix.com/2013/02/rxjava-netflix-api.html">RxJava is a key component for enabling server-side concurrency in Netflix's API</a>. Rx is not a framework restricted to one specific type of application or language. It really is a paradigm that you can use when programming any event-driven software.</p>
<p className="it">Si este tutorial te ayudó, <a href="https://twitter.com/intent/tweet?original_referer=https%3A%2F%2Fgist.github.com%2Fstaltz%2F868e7e9bc2a7b8c1f754%2F&amp;text=The%20introduction%20to%20Reactive%20Programming%20you%27ve%20been%20missing&amp;tw_p=tweetbutton&amp;url=https%3A%2F%2Fgist.github.com%2Fstaltz%2F868e7e9bc2a7b8c1f754&amp;via=andrestaltz">pío hacia adelante</a> .</p>
<p className="p">If this tutorial helped you, <a href="https://twitter.com/intent/tweet?original_referer=https%3A%2F%2Fgist.github.com%2Fstaltz%2F868e7e9bc2a7b8c1f754%2F&amp;text=The%20introduction%20to%20Reactive%20Programming%20you%27ve%20been%20missing&amp;tw_p=tweetbutton&amp;url=https%3A%2F%2Fgist.github.com%2Fstaltz%2F868e7e9bc2a7b8c1f754&amp;via=andrestaltz">tweet it forward</a>.</p>
<h3><a id="user-content-legal" class="anchor" href="#legal" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Legal</h3><p className="it">Â © Andre Cesar de Souza Medeiros (alias "Andre Staltz"), 2014. El uso no autorizado y / o reproducción de este material sin el permiso expreso y por escrito del autor y / o propietario € ™ s de este SiteA está estrictamente prohibido. Extractos y enlaces se pueden utilizar, siempre que el crédito completo y claro se da a Andre Medeiros y <a href="http://andre.staltz.com">http://andre.staltz.com</a> con dirección apropiada y específica para el contenido original.</p>
<p className="p">© Andre Cesar de Souza Medeiros (alias "Andre Staltz"), 2014. Unauthorized use and/or duplication of this material without express and written permission from this site’s author and/or owner is strictly prohibited. Excerpts and links may be used, provided that full and clear credit is given to Andre Medeiros and <a href="http://andre.staltz.com">http://andre.staltz.com</a> with appropriate and specific direction to the original content.</p>
<p className="p"><a href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" src="https://camo.githubusercontent.com/29dd0fb2d4b736b5726cc8202b39b04a24afbb48/68747470733a2f2f6c6963656e7365627574746f6e732e6e65742f6c2f62792d6e632f342e302f38387833312e706e67" data-canonical-src="https://licensebuttons.net/l/by-nc/4.0/88x31.png" /></a>"Introduction to Reactive Programming you've been missing" by <a href="http://andre.staltz.com">Andre Staltz</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.Based on a work at <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754"></a><a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">https://gist.github.com/staltz/868e7e9bc2a7b8c1f754</a>.</p> </div>
</div>  </Layout>
)
